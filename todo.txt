!
	TODO: strLiteral("-pedantic"),

!
	why is void mangling to "_voidvoid" ?

	writeMangledName looks to just do it once...

!
	// TODO: strLiteral("-pedantic"),

!
	//TODO: only used for side effect

!
	//TODO:eachwithindex

!
	compiler error when I wrote:

		new-linked-mut-queue by-val linked-mut-queue ?t() noctx
			new new<none>, new<none>

	should have been by-val linked-mut-queue<?t>

	but compiler shouldn't crash!





!
	new_linked_mut_queue
	used to return non-by-val

	Should have been a compile error to create a by-ref type with 'noctx'!

	same for new-mut-arr ...


!
	| TODO: should be able to infer type argument to null!

!
	`decr-noctx` has `noctx` highlighted

!
	noctx lambdas are hard??
	Should have a noctx-fun type maybe?


!
	"can't call a non-'noctx' fun": mention the name of the fun being called!

!
	ctx-by-v = new-ctx vat, actor-id

	This is wrong (should be colon after "new-ctx"), but the parse error was confusing.


!
	move 'everyPair' somewhere

!
	// TODO: make sure to infer type params in this case!

!
	make a backup!

!
	workerworkerworker -- rename!

!
	typesToConcreteTypes -> getConcreteTypes

!
	Kill TypeParamsScope? just use Arr<const TypeParam>

!
	Is FunDeclAndTypeArgs ever used independently of ConcreteFuNInst?

!
	size_t -> Nat


!
	Support comments at end of a line

!
	checkRef: have a getRef helper that doesn't take expected



!
	kill concretizeexprctx.currentconcretefun, that's in the concretefunsource ??


!
	rename concretefunInst?
	concretefun is fully-concrete
	concretefuninst is missing parameter specializations

!
	//TODO:MOVE

//TODO:EACHWITHINDEX

!
	showPos -> writePos?

!
	writeref

!
	concretizeCtx should carry MutDict<ConcreteFun*, uint16_t> recursionDepths.
	When we start filling in a function, increment it.
	When we're done, decrement and possibly delete it.
	I'f we're about to specialize arguments and recursionDepth is > 16, don't, leave them all as variable.


TODO
remove all '999' in include.nz

!
	'if' function that takes a single lambda and returns void
	another that returns opt ?t
		if opt ?t(cond bool, if-true ?t) noctx builtin
		if void(cond bool, if-true void) noctx builtin

!
	Writing constants:
	We should write the 'arrdata' constants first
	*then* write arrs and pointers

!
	bool_to_int helper

TODO
	Rename '_type' to '_typeWithoutKnownLambdaBody'

TODO
	too many functions called 'getallocfun'

TODO
	knownlambdabody closure fields should go in their own struct? make the whole thing optional?

!
	// TODO:PERF support constant unions


!
	_nuConstant :: don't take id as an argument, just hve a global id counter

! Output should just write to string, just be Writer.
Then printf at the end

!
	'type' of ConcreteExpr should be a getter. For most this is redundant.

!
	makeLambdasDynamic_forConstant and _forExpr: share code?

!
	KnownLambdaBody(const KnownLambdaBody&) = default;
	= delete?

TODO
	separate ConcreteExpr from ConcreteExprKind?

!
	//TODO: print type args too

!
	// TODO: also require return type to be immutable

TODO
	name fewer structs LambdaInfo


each-in-range -> Range type


TODO
	And remember: a struct with mutable properties *must* be by-reference!


TODO
`!=` looks like a message send!

| TODO: should be able to infer type argumetns

TODO
*Ast types to ExprAstKind::*

!
	//TODO:KILL (just write field->type everywhere)

!
	sort Expr members alphabetically


TODO
	| NOTE: this is not a normal record, compiler treats it specially
	Is this true?


	There's a SpecialStructKind for that but compiler doesn't actually do anything...


TODO
"the type of the expression" error: should print the type


Iterators?
	iterator record
		next fun0 opt<?t>

	find ?t(iter iterator)


!
	Ensure path given to command must have '.nz' extension

!
	move 'slice' to arrutil

!
	check path components must be valid in path constructor

!
	break up util.h

See // (TODO:RENAME)

!
	//TODO: cache this!

TODO
concretefunBody:
"builtin" should not be an option
Only "operator"

TODO
getBUiltinFunInfo should go in concretizeBuiltin.cpp

