| actual main function
main int64() trusted noctx summon
	ctx-by-val = as<by-val<ctx>>: new zero, zero, as-non-const: zero
	ctx-by-ptr = ctx-by-val ref-of-val
	ctx-by-ptr call-with-ctx &other-main
	zero

| Main function normally seen by users
other-main void() trusted summon
	m = empty-mut-dict<nat64, nat64>
	m add 1, 1
	m add 2, 2
	m add 3, 3
	d = m freeze
	identity = as-non-const<fun1<nat64, nat64>>: {it}
	uno = as-non-const<nat64>: 1
	dos = uno + uno
	| Closure should be by value
	add-one = as-non-const<fun1<nat64, nat64>>: {it + uno}
	| Closure should be a pointer
	add-three = as-non-const<fun1<nat64, nat64>>: {it + uno + dos}
	d2 = d map-values identity
	d3 = d map-values add-one
	d4 = d map-values add-three
	print-sync: d2 at 2 to-str
	print-sync: d3 at 2 to-str
	print-sync: d4 at 2 to-str

	| Find the sum of all the multiples of 3 or 5 below 1000.

iterator<?t> record mut
	next fun0 opt<?t>

cell<?t> record mut
	value mut ?t

get-and-incr nat64(c cell nat64)
	res = c value
	c.value := c.value incr
	res

iter iterator nat64(r range-nat64)
	n = new<cell<nat64>> r.lo
	new \
		when
			n.value == r.hi
				new<none>
			else
				new<some<nat64>> n get-and-incr


filter-helper opt nat64(i iterator nat64, pred fun1 bool nat64)
	x = i.next call
	match x
		none
			new<none>
		some s
			v = s.value
			when
				pred call v
					new<some<nat64>> v
				else
					i filter-helper pred


| TODO: more generic
filter iterator nat64(i iterator nat64, pred fun1 bool nat64)
	new {i filter-helper pred}


test void() trusted summon
	a = new-arr<nat64> one, one, one
	| get 0th element
	b = a.data deref
	b.to-str print-sync
	print-range: 5, 8, \x
		x.to-str print-sync

print-range void(lo nat64, hi nat64, f fun1 void nat64)
	when
		lo < hi
			f call lo
			lo.incr print-range hi, f
		else
			pass
