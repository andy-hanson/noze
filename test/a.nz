my-spec<?t> spec
	zero ?t()
	+ ?t(a ?t, b ?t)

my-sum ?t(a arr ?t) my-spec<?t>
	when
		a empty?
			zero
		else
			a.first + a.tail.my-sum

| actual main function
main int() trusted noctx summon
	| TODO: more threads
	n-threads = one as<nat>
	gctx-by-val = n-threads new-global-ctx
	gctx = gctx-by-val ref-of-val

	vat-by-val = new-vat: gctx, zero, n-threads
	vat = vat-by-val ref-of-val

	vats = new<arr<vat>> one, vat.ptr-to

	gctx.vats := vats

	| Before we start the engine, add a task.
	| Create a ctx manually so we can call functions that need it when creating the task
	ctx-by-val = new-ctx: gctx, vat, new<some<nat>> zero
	ctx = ctx-by-val ref-of-val
	ctx call-with-ctx<void, global-ctx, vat> &add-first-task, gctx, vat

	| TODO: more than one thread
	thread-function: zero, gctx

	| TODO: if main fut failed, return error code here
	zero

| TODO: if mut-bag-node is in unmanaged memory, don't need ctx for this
add-first-task void(gctx global-ctx, vat vat)
	actor-id = new<some<actor-id>> vat new-actor-id
	| TODO: store the main fut somewhere so we can test for errors
	t = new<task> actor-id, &user-main-drop
	vat add-task t





test void() trusted summon
	m = empty-mut-dict<nat, nat>
	m add 1, 1
	m add 2, 2
	m add 3, 3
	d = m freeze
	identity = as-non-const<fun1<nat, nat>>: {it}
	uno = as-non-const<nat>: 1
	dos = uno + uno
	| Closure should be by value
	add-one = as-non-const<fun1<nat, nat>>: {it + uno}
	| Closure should be a pointer
	add-three = as-non-const<fun1<nat, nat>>: {it + uno + dos}
	d2 = d map-values identity
	d3 = d map-values add-one
	d4 = d map-values add-three
	print-sync: d2 at 2 to-str
	print-sync: d3 at 2 to-str
	print-sync: d4 at 2 to-str


is-multiple? bool(a nat, b nat)
	a mod b == 0

f nat(s stream nat)
	s sum

user-main-drop void() summon
	user-main drop

| Main function normally seen by users
user-main fut void() trusted summon
	| rgs = (zero to 1000).to-stream<range-nat, nat>
	| filtered = rgs filter {it is-multiple? 3 or: it is-multiple? 5}
	| x = filtered sum
	| assert: x == 233168
	| print-sync: x.to-str

	resolved: print-sync: "hello world"


	| n = (new-arr<nat> 1, 2, 3) my-sum
	| print-sync: n.to-str

	| count-down

	| pass


| printer iface
|	print void(s str)

| make-printer printer() summon
|	new-actor()
|		print(s)
|			resolved: print-sync: s


n-times void(n nat, f fun1 void nat)
	f call n
	n == 0 if: pass, n.decr n-times f

count-down void() summon
	10 n-times {it.to-str print-sync}


test void() trusted summon
	a = new-arr<nat> one, one, one
	| get 0th element
	b = a.data deref
	b.to-str print-sync
	print-range: 5, 8, \x
		x.to-str print-sync

print-range void(lo nat, hi nat, f fun1 void nat)
	when
		lo < hi
			f call lo
			lo.incr print-range hi, f
		else
			pass
