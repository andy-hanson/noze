import arr-utils cell dict gc io number-utils runtime str-utils

my-spec<?t> spec
	zero ?t()
	+ ?t(a ?t, b ?t)

my-sum ?t(a arr ?t) my-spec<?t>
	when
		a empty?
			zero
		else
			a.first + a.tail.my-sum

test void() trusted summon
	m = empty-mut-dict<nat, nat>
	m add 1, 1
	m add 2, 2
	m add 3, 3
	d = m freeze
	identity = as-non-const<fun-mut1<nat, nat>>: {it}
	uno = as-non-const<nat>: 1
	dos = uno + uno
	| Closure should be by value
	add-one = as-non-const<fun-mut1<nat, nat>>: {it + uno}
	| Closure should be a pointer
	add-three = as-non-const<fun-mut1<nat, nat>>: {it + uno + dos}
	d2 = d map-values identity
	d3 = d map-values add-one
	d4 = d map-values add-three
	print-sync: d2 at 2 to-str
	print-sync: d3 at 2 to-str
	print-sync: d4 at 2 to-str


lines arr str(s str)
	res = new-mut-arr<str>
	last-nl = zero new-cell<nat>
	s each-with-index \c index
		when
			c == "\n"
				res add: s slice-from-to (last-nl swap index.incr), index
			else
				pass
	res add: s slice-from-to last-nl.get, s.size
	res.freeze


max-line-length nat()
	120

n-tabs nat(line str)
	when
		line.empty?.not and: line.first == "\t"
			line.tail.n-tabs incr
		else
			zero

tab-size nat()
	4

line-len nat(line str)
	line.n-tabs * (tab-size - 1) + line.size


| Returns nubmer of errors
lint-file nat(file-name str) summon
	text = file-name.read-file
	n-errors = 0 new-cell<nat>
	text.lines each-with-index \line line-num
		width = line line-len
		when
			width > max-line-length
				loc = file-name + ":" + line-num.incr.to-str
				print-sync: loc + " line is " + width.to-str + " columns long, should be <= " + max-line-length.to-str
				n-errors cell-incr
			else
				pass
	n-errors get


child-path str(a str, child-name str)
	a + "/" + child-name

each-child-recursive void(d str, filter fun-mut1 bool str, f fun-mut1 void str) summon
	when
		d is-dir?
			d.read-dir each \child-name
				when
					filter call child-name
						d child-path child-name each-child-recursive filter, f
					else
						pass
		else
			f call d

last-index-of opt nat(s str, c char)
	when
		s empty?
			none
		s.last == c
			s.size.decr some
		else
			s.rtail last-index-of c

get-ext opt str(name str)
	match name last-index-of "."
		none
			none
		some s
			name slice s.value some

| IGNORE_EXTS = Set({ ".c", ".data", ".o", ".tmLanguage" })
ignore-ext bool(ext str)
	(new-arr<str> ".c", ".data", ".o", ".out", ".tmLanguage") contains ext

ignore-ext-of-name bool(name str)
	match name get-ext
		none
			| Ignore extensionless files
			true
		some s
			s.value ignore-ext


base-name str(path str)
	i = path last-index-of "/"
	match i
		none
			path
		some s
			path slice s.value.incr


lint void() summon

	n-files = 0 new-cell<nat>
	n-errors = 0 new-cell<nat>

	"." each-child-recursive {not: it.first == "." or: it == "libfirm"}, \child
		when
			child.base-name ignore-ext-of-name
				pass
			else
				n-files cell-incr
				n-errors cell-add child.lint-file

	print-sync: "Linted " + n-files.get.to-str + " files, " + n-errors.get.to-str + " errors"


| Main function normally seen by users
user-main fut int32(args arr str) trusted summon
	fut-two = async<nat>: \
		resolved: two

	printer <- make-printer
	tw <- fut-two
	thr = tw.incr
	ignore <- printer call thr.to-str
	resolved: zero

printer alias
	fun-ref1 void str

make-printer fut printer() summon
	async: \
		resolved: \s
			resolved: print-sync: s


n-times void(n nat, f fun1 void nat)
	f call n
	n == 0 if: pass, n.decr n-times f

count-down void() summon
	10 n-times {it.to-str print-sync}


test void() trusted summon
	a = new-arr<nat> one, one, one
	| get 0th element
	b = a.data deref
	b.to-str print-sync
	print-range: 5, 8, \x
		x.to-str print-sync

print-range void(lo nat, hi nat, f fun1 void nat)
	when
		lo < hi
			f call lo
			lo.incr print-range hi, f
		else
			pass
