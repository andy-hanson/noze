
u-long alias
	nat
s-long alias
	int
dev-t alias
	u-long
ino-t alias
	u-long
mode-t alias
	u-long
nlink-t alias
	u-long
uid-t alias
	u-long
gid-t alias
	u-long
off-t alias
	s-long
blksize-t alias
	s-long
blkcnt-t alias
	s-long
time-t alias
	s-long
stat-t record mut
	st-dev mut dev-t
	st-ino mut ino-t
	st-mode mut mode-t
	st-nlink mut nlink-t
	st-uid mut uid-t
	st-gid mut gid-t
	st-rdev mut dev-t
	pad mut u-long
	st-size mut off-t
	st-blksize mut blksize-t
	st-blocks mut blkcnt-t
	st-atime mut time-t
	st-atime-nsec mut u-long
	st-mtime mut time-t
	st-mtime-nsec mut u-long
	st-ctime mut time-t
	st-ctime-msec mut u-long
	unused mut u-long

err-t alias
	int32

enoent err-t()
	two

get-errno err-t() summon builtin

stat int32(path c-str, buf stat-t) extern

get-stat opt stat-t(path c-str) summon trusted
	s = new<stat-t> zero, zero, zero, zero, zero, zero, zero, zero, zero, zero, zero, zero, zero, zero, zero, zero, zero, zero
	err = path stat s
	when
		err == zero
			new<some<stat-t>> s
		else
			assert: err == neg-one
			errno = get-errno
			when
				errno == enoent
					new<none>
				else
					print-sync: "stat failed: "
					print-sync: errno.to-str
					todo

| TODO: move to io.nz
file-exists? bool(path c-str) summon
	path.get-stat has?

file-exists? bool(path str) summon
	path.data file-exists?

my-spec<?t> spec
	zero ?t()
	+ ?t(a ?t, b ?t)

my-sum ?t(a arr ?t) my-spec<?t>
	when
		a empty?
			zero
		else
			a.first + a.tail.my-sum

| actual main function
main int() trusted noctx summon
	| TODO: more threads
	n-threads = one as<nat>
	gctx-by-val = n-threads new-global-ctx
	gctx = gctx-by-val ref-of-val

	vat-by-val = new-vat: gctx, zero, n-threads
	vat = vat-by-val ref-of-val

	vats = new<arr<vat>> one, vat.ptr-to

	gctx.vats := vats

	| Before we start the engine, add a task.
	| Create a ctx manually so we can call functions that need it when creating the task
	ctx-by-val = new-ctx: gctx, vat, new<some<nat>> zero
	ctx = ctx-by-val ref-of-val
	ctx call-with-ctx<void, global-ctx, vat> &add-first-task, gctx, vat

	| TODO: more than one thread
	thread-function: zero, gctx

	| TODO: if main fut failed, return error code here
	zero

| TODO: if mut-bag-node is in unmanaged memory, don't need ctx for this
add-first-task void(gctx global-ctx, vat vat)
	actor-id = new<some<actor-id>> vat new-actor-id
	| TODO: store the main fut somewhere so we can test for errors
	t = new<task> actor-id, &user-main-drop
	vat add-task t





test void() trusted summon
	m = empty-mut-dict<nat, nat>
	m add 1, 1
	m add 2, 2
	m add 3, 3
	d = m freeze
	identity = as-non-const<fun1<nat, nat>>: {it}
	uno = as-non-const<nat>: 1
	dos = uno + uno
	| Closure should be by value
	add-one = as-non-const<fun1<nat, nat>>: {it + uno}
	| Closure should be a pointer
	add-three = as-non-const<fun1<nat, nat>>: {it + uno + dos}
	d2 = d map-values identity
	d3 = d map-values add-one
	d4 = d map-values add-three
	print-sync: d2 at 2 to-str
	print-sync: d3 at 2 to-str
	print-sync: d4 at 2 to-str


is-multiple? bool(a nat, b nat)
	a mod b == 0

f nat(s stream nat)
	s sum

user-main-drop void() summon
	user-main drop

| Main function normally seen by users
user-main fut void() trusted summon
	| rgs = (zero to 1000).to-stream<range-nat, nat>
	| filtered = rgs filter {it is-multiple? 3 or: it is-multiple? 5}
	| x = filtered sum
	| assert: x == 233168
	| print-sync: x.to-str

	print-sync: "hello world"

	files = new-arr<str> "test/a.nz", "test/b.nz"
	files each \file
		a = file.file-exists?
		print-sync: file + " exists? " + a.to-str

	resolved: pass

	| n = (new-arr<nat> 1, 2, 3) my-sum
	| print-sync: n.to-str

	| count-down

	| pass


| printer iface
|	print void(s str)

| make-printer printer() summon
|	new-actor()
|		print(s)
|			resolved: print-sync: s


n-times void(n nat, f fun1 void nat)
	f call n
	n == 0 if: pass, n.decr n-times f

count-down void() summon
	10 n-times {it.to-str print-sync}


test void() trusted summon
	a = new-arr<nat> one, one, one
	| get 0th element
	b = a.data deref
	b.to-str print-sync
	print-range: 5, 8, \x
		x.to-str print-sync

print-range void(lo nat, hi nat, f fun1 void nat)
	when
		lo < hi
			f call lo
			lo.incr print-range hi, f
		else
			pass
