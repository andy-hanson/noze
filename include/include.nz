region basic

| Unrecoverable assertion failure
hard-fail ?t(reason str) noctx unsafe builtin

fail ?t(reason str)
	todo

todo ?t() trusted noctx
	| TODO: soft-fail, remove 'trusted' above
	hard-fail: "TODO"

region system

by-val<?t> builtin

| Unsafe because the ref will only be valid temporarily!
ref-of-val ?t(b by-val ?t) noctx unsafe builtin

| This forces something to be stack-allocated.
| WARN: If '?t' is a reference type already, this is a pointer to a pointer!
ptr-to ptr ?t(t ?t) noctx unsafe builtin

| TODO: this function only works for by-ref types -- currently that is not checked by the type checker
as-any-ptr any-ptr(some-ref ?t) noctx unsafe builtin

ptr-eq bool(a ?t, b ?t) noctx unsafe
	a.as-any-ptr == b.as-any-ptr

| Since this fun is not marked 'noctx', it simply returns the ctx that already exists.
get-ctx ctx() unsafe builtin

void builtin
byte builtin

| NOTE: if ?t is a reference type, ptr<?t> is a pointer to a pointer to ?t
ptr<?t> builtin
deref ?t(p ptr ?t) noctx unsafe builtin
set void(p ptr ?t, value ?t) noctx unsafe builtin

null ptr ?t() noctx builtin

any-ptr alias
	ptr byte

is-reference-type?<?t> bool() noctx unsafe builtin
size-of<?t> nat() noctx unsafe builtin

size-or-pointer-size<?t> nat() noctx unsafe
	when
		is-reference-type?<?t>
			size-of<ptr<void>>
		else
			size-of<?t>

ptr-cast ptr ?out(p ptr ?in) noctx unsafe builtin

to-nat nat(p ptr ?t) noctx unsafe builtin

+ ptr ?t(p ptr ?t, offset nat) noctx unsafe builtin
- ptr ?t(p ptr ?t, offset nat) noctx unsafe builtin
- nat(a ptr ?t, b ptr ?t) noctx unsafe
	a - b.to-nat to-nat

malloc any-ptr(size nat) unsafe extern

get-gc gc() unsafe
	get-ctx.vat.gc.ref-of-val

alloc any-ptr(size nat) unsafe
	get-gc gc-alloc size

region comparison

less record
equal record
greater record
comparison union
	less
	equal
	greater

<=> comparison(a ?t, b ?t) noctx builtin

== bool(a ?t, b ?t) noctx
	match a <=> b
		less
			false
		equal
			true
		greater
			false

| != bool(a ?t, b ?t)
|	a == b not

< bool(a ?t, b ?t) noctx
	match a <=> b
		less
			true
		equal
			false
		greater
			false

<= bool(a ?t, b ?t) noctx
	b < a not

> bool(a ?t, b ?t) noctx
	a <= b not

>= bool(a ?t, b ?t) noctx
	a < b not

min ?t(a ?t, b ?t) noctx
	(a < b) if a, b

max ?t(a ?t, b ?t) noctx
	(a > b) if a, b

region str

char builtin
str alias
	arr char
c-str alias
	ptr char

literal char(s str) noctx
	s noctx-at zero

literal c-str(s str) noctx
	s data

to-c-str c-str(s str)
	| Need to add the null character to the end
	s + "\0" data

to-str str(c c-str) unsafe noctx
	end = c find-cstr-end
	c arr-from-begin-end end

find-cstr-end c-str(c c-str) unsafe noctx
	when
		c.deref == "\0"
			c
		else
			c.incr find-cstr-end

region bool

bool builtin
false bool() noctx builtin
true bool() noctx builtin
not bool(a bool) noctx builtin
| Note: this should be lazily evaluated
and bool(a bool, b bool) noctx builtin
or bool(a bool, b bool) noctx builtin
nand bool(a bool, b bool) noctx builtin
nor bool(a bool, b bool) noctx builtin
| Only one of 'if-true' and 'if-false' arguments will be evaluated
if ?t(cond bool, if-true ?t, if-false ?t) noctx builtin
if void(cond bool, if-true void) noctx builtin

region Fun

| Pointer to a function with no arguments (not even ctx)
fun-ptr0<?r> builtin
fun-ptr1<?r, ?p0> builtin
fun-ptr2<?r, ?p0, ?p1> builtin
fun-ptr3<?r, ?p0, ?p1, ?p2> builtin
fun-ptr4<?r, ?p0, ?p1, ?p2, ?p3> builtin

| A fun is two pointers -- one to the fun pointer, one to the closure.
| TODO: point to the vtable, and have vtable also store layout information
| A send-fun is a fun plus a vat and actor id.
fun0<?r> record mut
	fun-ptr fun-ptr2 ?r ctx any-ptr
	closure any-ptr
fun1<?r, ?p0> record mut
	fun-ptr fun-ptr3 ?r ctx any-ptr ?p0
	closure any-ptr
fun2<?r, ?p0, ?p1> record mut
	fun-ptr fun-ptr4 ?r ctx any-ptr ?p0 ?p1
	closure any-ptr

| A normal fun is non-sendable, a send-fun becomes sendable by storing the vat/actor that will provide its ctx.
send-fun0<?r> record force-sendable
	vat-and-actor vat-and-actor-id
	fun fun0 ?r
send-fun1<?r, ?p0> record force-sendable
	vat-and-actor vat-and-actor-id
	fun fun1 ?r ?p0
send-fun2<?r, ?p0, ?p1> record force-sendable
	vat-and-actor vat-and-actor-id
	fun fun2 ?r ?p0 ?p1

| calling a fun-ptr is a primitive operation
call ?r(f fun-ptr0 ?r) noctx builtin
call ?r(f fun-ptr1 ?r ?p0, p0 ?p0) noctx builtin
call ?r(f fun-ptr2 ?r ?p0 ?p1, p0 ?p0, p1 ?p1) noctx builtin
call ?r(f fun-ptr3 ?r ?p0 ?p1 ?p2, p0 ?p0, p1 ?p1, p2 ?p2) noctx builtin
call ?r(f fun-ptr4 ?r ?p0 ?p1 ?p2 ?p3, p0 ?p0, p1 ?p1, p2 ?p2, p3 ?p3) noctx builtin

| Note: this is the implementation for a dynamic call.
| But the compiler may call the function dynamically instead
call ?r(f fun0 ?r) trusted
	get-ctx call-with-ctx f

call-with-ctx ?r(c ctx, f fun0 ?r) noctx
	f.fun-ptr call c, f.closure

call ?r(f fun1 ?r ?p0, p0 ?p0) trusted
	get-ctx call-with-ctx f, p0

call-with-ctx ?r(c ctx, f fun1 ?r ?p0, p0 ?p0) noctx
	f.fun-ptr call c, f.closure, p0

call ?r(f fun2 ?r ?p0 ?p1, p0 ?p0, p1 ?p1) trusted
	get-ctx call-with-ctx f, p0, p1

call-with-ctx ?r(c ctx, f fun2 ?r ?p0 ?p1, p0 ?p0, p1 ?p1) noctx
	f.fun-ptr call c, f.closure, p0, p1

call fut ?r(f send-fun0 ?r) trusted
	| Create a future
	| Put the task on the vat, that will write to the future
	| Return the future
	ctx = get-ctx
	gctx = ctx.gctx
	vat-i = f.vat-and-actor.vat
	actor-i = f.vat-and-actor.actor
	vat = gctx.vats at vat-i
	res = new-unresolved-fut<?r>
	| Add a task to resolve it
	t = new<task> actor-i.some, \
		res resolve: f.fun.call
	vat add-task t
	res

call fut ?r(f send-fun1 ?r ?p0, p0 ?p0)
	todo

call fut ?r(f send-fun2 ?r ?p0 ?p1, p0 ?p0, p1 ?p1)
	todo

region Arithmetic

| All are 64-bits, even on 32-bit systems
nat builtin
int builtin
float builtin
| Not currently used for anything other than posix headers, so limited arithmetic is avialable
int16 builtin
int32 builtin
nat16 builtin
nat32 builtin

| UB for negative numbers
unsafe-to-nat nat(i int) noctx builtin

unsafe-to-nat32 nat32(n nat) noctx builtin

| UB for positive numbers >= 2 ** 63
unsafe-to-int int(n nat) noctx builtin

to-nat nat(n nat16) noctx builtin
to-nat nat(n nat32) noctx builtin

to-int int(i int16) noctx builtin
to-int int(i int32) noctx builtin

wrap-add nat(a nat, b nat) noctx builtin
wrap-add nat32(a nat32, b nat32) noctx builtin
wrap-sub nat(a nat, b nat) noctx builtin
wrap-mul nat(a nat, b nat) noctx builtin
unsafe-div nat(a nat, b nat) noctx unsafe builtin
unsafe-mod nat(a nat, b nat) noctx unsafe builtin
zero nat() noctx builtin
one nat() noctx builtin
two nat() noctx
	one wrap-incr
three nat() noctx
	two wrap-incr
four nat() noctx
	three wrap-incr
five nat() noctx
	four wrap-incr
six nat() noctx
	five wrap-incr
seven nat() noctx
	six wrap-incr
eight nat() noctx
	seven wrap-incr
nine nat() noctx
	eight wrap-incr
ten nat() noctx
	nine wrap-incr
hundred nat() noctx
	ten wrap-mul ten
thousand nat() noctx
	hundred wrap-mul ten
million nat() noctx
	thousand wrap-mul thousand
billion nat() noctx
	million wrap-mul thousand

bits-and nat16(a nat16, b nat16) noctx builtin
bits-and nat32(a nat32, b nat32) noctx builtin
bits-and nat(a nat, b nat) noctx builtin

| TODO: generic
zero? bool(n nat) noctx
	n == zero
zero? bool(i int) noctx
	i == zero

wrap-add int(a int, b int) noctx builtin
wrap-sub int(a int, b int) noctx builtin
wrap-mul int(a int, b int) noctx builtin
unsafe-div int(a int, b int) noctx unsafe builtin
zero int() noctx builtin
one int() noctx builtin
neg-one int() noctx
	zero wrap-sub one
two int() noctx
	one wrap-incr
three int() noctx
	two wrap-incr
four int() noctx
	three wrap-incr
five int() noctx
	four wrap-incr
six int() noctx
	five wrap-incr
seven int() noctx
	six wrap-incr
eight int() noctx
	seven wrap-incr
nine int() noctx
	eight wrap-incr
ten int() noctx
	nine wrap-incr
hundred int() noctx
	ten wrap-mul ten
thousand int() noctx
	hundred wrap-mul ten
million int() noctx
	thousand wrap-mul thousand
neg-million int() noctx
	million wrap-mul neg-one
billion int() noctx
	million wrap-mul thousand

wrap-add int32(a int32, b int32) noctx builtin
wrap-sub int32(a int32, b int32) noctx builtin
zero int32() noctx builtin
one int32() noctx builtin
neg-one int32() noctx
	zero wrap-sub one
two int32() noctx
	one wrap-add one

zero nat32() noctx builtin
one nat32() noctx builtin
two nat32() noctx
	one wrap-add one
zero nat16() noctx builtin

wrap-incr nat(n nat) noctx
	n wrap-add one

noctx-incr nat(n nat) noctx unsafe
	| TODO: billion should be max-value
	hard-assert: n < billion
	n wrap-incr

incr nat(n nat)
	| TODO: billion should be max-value
	assert: n < billion
	n wrap-add one

wrap-incr int(i int) noctx
	i wrap-add one

incr int(i int)
	| TODO: billion should be max-value
	assert: i < billion
	i wrap-add one

incr ptr ?t(p ptr ?t) noctx unsafe
	p + one

noctx-decr nat(n nat) noctx unsafe
	hard-forbid: n zero?
	n wrap-sub one

decr nat(n nat)
	forbid: n zero?
	n wrap-sub one

| decr int(i int)
|	i - 1

decr ptr ?t(p ptr ?t) noctx unsafe
	p - one

+ nat(a nat, b nat)
	res = a wrap-add b
	assert: res >= a and: res >= b
	res
- nat(a nat, b nat)
	assert: a >= b
	a wrap-sub b
* nat(a nat, b nat)
	| TODO: better safety check
	when
		a.zero? or: b.zero?
			zero
		else
			res = a wrap-mul b
			assert: res / b == a
			assert: res / a == b
			res
/ nat(a nat, b nat) trusted
	forbid: b zero?
	a unsafe-div b

mod nat(a nat, b nat) trusted
	forbid: b zero?
	a unsafe-mod b

+ int(a int, b int)
	| TODO: better safety check
	assert: a > neg-million
	assert: a < million
	assert: b > neg-million
	assert: b < million
	a wrap-add b

- int(a int, b int)
	| TODO: better safety check
	assert: a > neg-million
	assert: a < million
	assert: b > neg-million
	assert: b < million
	a wrap-sub b
* int(a int, b int)
	assert: a > neg-million
	assert: a < million
	assert: b > neg-million
	assert: b < million
	a wrap-mul b
/ int(a int, b int) trusted
	forbid: b zero?
	| If a is the smallest int and b is -1, result is UB
	| TODO: better safety check
	assert: a > neg-million
	a unsafe-div b

to-int int(n nat)
	| assert: n < (32 pow2)
	assert: n < million
	n unsafe-to-int

to-nat nat(i int)
	forbid: i.negative?
	i unsafe-to-nat

negative? bool(i int)
	i < zero

neg int(i int)
	i * neg-one

neg int(n nat)
	n.to-int neg

abs nat(i int)
	i-abs = i.negative? if i.neg, i
	i-abs to-nat

mod nat(a int, b nat)
	forbid: b zero?
	when
		a negative?
			x = a.abs mod b
			x == b if: zero, b - x
		else
			a.to-nat mod b

+ float(a float, b float) noctx builtin
- float(a float, b float) noctx builtin
* float(a float, b float) noctx builtin
unsafe-div float(a float, b float) noctx unsafe builtin
zero float() noctx builtin
one float() noctx builtin

char-to-nat nat(c char) noctx
	when
		c == "0"
			zero
		c == "1"
			one
		c == "2"
			two
		c == "3"
			three
		c == "4"
			four
		c == "5"
			five
		c == "6"
			six
		c == "7"
			seven
		c == "8"
			eight
		c == "9"
			nine
		else
			todo

literal nat(s str)
	when
		s empty?
			zero
		else
			higher-digits = s.rtail.literal as<nat>
			higher-digits * ten + (char-to-nat: s last)

literal nat32(s str)
	s.literal.as<nat> unsafe-to-nat32

literal int(s str)
	fst = s at zero
	when
		fst == "-"
			n = as<nat>: s.tail.literal
			n neg
		fst == "+"
			s.tail.literal.as<nat> to-int
		else
			s.literal.as<nat> to-int

region Util

pass void() noctx builtin
pass fut void() noctx builtin
drop void(t ?t) noctx
	pass

hard-assert void(condition bool) noctx unsafe
	when
		condition
			pass
		else
			"Assertion failed!" hard-fail

assert void(condition bool)
	when
		condition
			pass
		else
			"Assertion failed!" fail

hard-forbid void(condition bool) noctx unsafe
	condition.not hard-assert

forbid void(condition bool)
	condition.not assert

hard-assert-unreachable ?t() noctx unsafe
	"should be unreachable" hard-fail

assert-unreachable ?t()
	"should be unreachable" fail

some<?t> record
	by-val
	value ?t
none record
opt<?t> union
	none
	some<?t>

some some ?t(t ?t) noctx
	new t

none none() noctx
	new<none>


empty? bool(a opt ?t) noctx
	match a
		none n
			true
		some s
			false

has? bool(a opt ?t) noctx
	a.empty? not

force ?t(a opt ?t)
	match a
		none n
			fail: "tried to force empty option"
		some s
			s.value



ok<?t> record
	by-val
	value ?t
err<?t> record
	by-val
	value ?t
result<?ok, ?err> union
	ok<?ok>
	err<?err>

ok ok ?t(t ?t) noctx
	new t
err err ?t(t ?t) noctx
	new t


as ?t(value ?t) noctx builtin
as-non-const ?t(value ?t) noctx builtin

region fut

fut-callback-node<?t> record mut
	| WARN: the cb will be called with whatever ctx resolves the fut
	cb fun1 void ?t
	next-node opt fut-callback-node<?t>

fut-state-callbacks<?t> record mut
	head opt fut-callback-node<?t>

fut-state-resolved<?t> record
	value ?t

fut-state<?t> union mut
	fut-state-callbacks<?t>
	fut-state-resolved<?t>

fut<?t> record force-sendable
	lk by-val lock
	state mut fut-state ?t

| Considered unsafe because normally it should not be possible to never resolve a fut
new-unresolved-fut fut ?t() unsafe
	new new-lock, new<fut-state-callbacks<?t>> none

resolved fut ?t(value ?t)
	new new-lock, new<fut-state-resolved<?t>> value

resolve void(f fut ?t, value ?t) unsafe
	f.lk.ref-of-val acquire-lock
	match f.state
		fut-state-callbacks cbs
			cbs.head resolve-recur value
		fut-state-resolved
			hard-fail: "resolving an already-resolved fut"
	f.state := new<fut-state-resolved<?t>> value
	f.lk.ref-of-val release-lock

resolve-recur void(node opt fut-callback-node<?t>, value ?t)
	match node
		none
			pass
		some s
			| the send-fun will return a fut<void>, just ignore it
			drop: s.value.cb call value
			s.value.next-node resolve-recur value

| NOTE: The function will be called with whatever ctx the fut terminates with!!!
then-void void(f fut ?t, cb fun1 void ?t) unsafe
	f.lk.ref-of-val acquire-lock
	res = match f.state
		fut-state-callbacks cbs
			| create a new callback
			f.state := new<fut-state-callbacks<?t>> some: new cb, cbs.head
		fut-state-resolved r
			cb call r.value
	f.lk.ref-of-val release-lock
	res

forward-to void(from fut ?t, to fut ?t) unsafe
	from then-void \value
		to resolve value

then fut ?out(f fut ?in, cb send-fun1 ?out ?in) trusted
	res = new-unresolved-fut<?out>
	f then-void \value
		cb call value forward-to res
	res

joiner<?out, ?in0, ?in1> record force-sendable
	res fut ?out
	fun send-fun2 ?out ?in0 ?in1
	arg0 mut opt ?in0
	arg1 mut opt ?in1
	| NOTE: we can't just check that both arg0 and arg1 are done -- we might try calling 'fun' twice.
	| We need to atomically decrement the counter so we only call 'fun' once
	n-remaining-args by-val thread-safe-counter

decr-joiner void(j joiner ?out ?in0 ?in1) unsafe
	when
		j.n-remaining-args.ref-of-val decrement
			j.fun call j.arg0.force, j.arg1.force forward-to j.res
		else
			pass

join fut ?out(a fut ?in0, b fut ?in1, fun send-fun2 ?out ?in0 ?in1) trusted
	res = new-unresolved-fut<?out>
	joiner = new<joiner<?out, ?in0, ?in1>> res, fun, none, none, new-thread-safe-counter: 2
	a then-void \value
		joiner.arg0 := value some
		joiner decr-joiner
	b then-void \value
		joiner.arg1 := value some
		joiner decr-joiner
	res

region arr

| NOTE: this is not a normal record, compiler treats it specially
arr<?t> record
	by-val
	size nat
	data ptr ?t

arr-from-begin-end arr ?t(begin ptr ?t, end ptr ?t) unsafe noctx
	new (end - begin), begin

empty-arr arr ?t() noctx trusted
	new zero, null

empty? bool(a arr ?t) noctx
	a.size zero?

slice arr ?t(a arr ?t, begin nat, size nat) trusted
	assert: begin + size <= a.size
	new size, a.data + begin

slice-from-to arr ?t(a arr ?t, begin nat, end nat) trusted
	assert: begin <= end
	a slice: begin, end - begin

slice arr ?t(a arr ?t, begin nat)
	assert: begin <= a.size
	a slice: begin, a.size - begin

first ?t(a arr ?t)
	forbid: a empty?
	a at zero

last ?t(a arr ?t)
	forbid: a empty?
	a at a.size.decr

tail arr ?t(a arr ?t)
	forbid: a empty?
	a slice one

rtail arr ?t(a arr ?t)
	forbid: a empty?
	a slice zero, a.size.decr

noctx-at ?t(a arr ?t, index nat) trusted noctx
	hard-assert: index < a.size
	a.data + index deref

at ?t(a arr ?t, index nat) trusted
	assert: index < a.size
	a noctx-at index

+ arr ?t(a arr ?t, b arr ?t) trusted
	m = uninitialized-mut-arr<?t>: a.size + b.size
	zero to a.size each \i
		m set-at: i, a at i
	zero to b.size each \i
		m set-at: (i + a.size), (b at i)
	m freeze


mut-slice<?t> record mut
	size nat
	data ptr ?t

slice mut-slice ?t(a mut-slice ?t, lo nat, size nat) trusted
	assert: lo + size <= a.size
	new size, a.data + lo

slice mut-slice ?t(a mut-slice ?t, lo nat)
	assert: lo <= a.size
	a slice: lo, a.size - lo

at ?t(a mut-slice ?t, index nat) trusted
	assert: index < a.size
	a.data + index deref

set void(a mut-slice ?t, index nat, value ?t) trusted
	assert: index < a.size
	a.data + index set value

| UNSAFE since it can't track whether the underlying mut-arr was frozen (or reallocated)
to-mut-slice mut-slice ?t(a mut-arr ?t) unsafe
	forbid: a.frozen
	new a.size, a.data

sort arr ?t(a arr ?t)
	m = a to-mut-arr
	m sort
	m freeze

swap void(a mut-slice ?t, lo nat, hi nat)
	old-lo = a at lo
	a set: lo, a at hi
	a set hi, old-lo

sort void(a mut-arr ?t) trusted
	a.to-mut-slice sort

sort void(a mut-slice ?t)
	when
		a.size <= one
			pass
		else
			| Perf -- in case a is sorted already, prefer the middle element as a pivot
			a swap zero, (a.size / two)
			pivot = a at zero
			index-of-first-value-gt-pivot = a partition-recur pivot, one, a.size.decr
			new-pivot-index = index-of-first-value-gt-pivot.decr
			a swap zero, new-pivot-index

			sort: a slice zero, new-pivot-index
			sort: a slice new-pivot-index.incr


| Returns index of first value > pivot
partition-recur nat(a mut-slice ?t, pivot ?t, l nat, r nat)
	assert: l <= a.size
	assert: r < a.size
	when
		l <= r
			em = a at l
			when
				em < pivot
					a partition-recur pivot, l.incr, r
				else
					a swap l, r
					a partition-recur pivot, l, r.decr
		else
			l


| NOTE: this is not a normal record, compiler treats it specially
mut-arr<?t> record mut
	frozen mut bool
	| Number of *initialized* elements.
	| But 'uninitialized-mut-arr' sets 'size' and doesn't initialize!
	size mut nat
	capacity mut nat
	data mut ptr ?t

temp-as-arr arr ?t(a mut-arr ?t) unsafe noctx
	new a.size, a.data

uninitialized-data ptr ?t(size nat) unsafe
	bptr = alloc: size wrap-mul size-of<?t>
	bptr ptr-cast<?t, byte>

uninitialized-mut-arr mut-arr ?t(size nat) unsafe
	new false, size, size, uninitialized-data<?t>: size

new-mut-arr mut-arr ?t() trusted
	new false, zero, zero, null

new-mut-arr-by-val by-val mut-arr<?t>() noctx trusted
	new false, zero, zero, null

new-mut-arr-by-val-with-capacity-from-unmanaged-memory by-val mut-arr<?t>(capacity nat) noctx unsafe
	new false, zero, capacity, capacity unmanaged-alloc-elements<?t>

empty? bool(a mut-arr ?t) noctx
	a.size zero?

noctx-set-at void(a mut-arr ?t, index nat, value ?t) noctx trusted
	hard-assert: index < a.size
	(a.data + index) set value

set-at void(a mut-arr ?t, index nat, value ?t) trusted
	assert: index < a.size
	a noctx-set-at index, value

noctx-last ?t(a mut-arr ?t) noctx unsafe
	hard-forbid: a empty?
	a noctx-at a.size.noctx-decr

noctx-remove-unordered-at-index ?t(a mut-arr ?t, index nat) noctx unsafe
	res = a noctx-at index
	a noctx-set-at index, a.noctx-last
	a.size := a.size.noctx-decr
	res



contains bool(a arr ?t, value ?t) noctx
	a contains-recur value, zero

contains bool(a mut-arr ?t, value ?t) noctx trusted
	a.temp-as-arr contains-recur value, zero

contains-recur bool(a arr ?t, value ?t, i nat) noctx trusted
	when
		i == a.size
			false
		else
			a noctx-at i == value or: a contains-recur value, i.noctx-incr

push-capacity-must-be-sufficient void(a mut-arr ?t, value ?t) noctx unsafe
	hard-assert: a.size < a.capacity
	old-size = a.size
	a.size := old-size.noctx-incr
	a noctx-set-at old-size, value

noctx-must-remove-unordered-recur void(a mut-arr ?t, index nat, value ?t) noctx unsafe
	when
		index == a.size
			hard-fail: "Did not find the element in the mut-arr"
		a noctx-at index == value
			a noctx-remove-unordered-at-index index drop
		else
			a noctx-must-remove-unordered-recur index.noctx-incr, value

noctx-must-remove-unordered void(a mut-arr ?t, value ?t) noctx unsafe
	a noctx-must-remove-unordered-recur zero, value



| Unsafe as this does *not* freeze it!
unsafe-as-arr arr ?t(a mut-arr ?t) noctx unsafe
	new a.size, a.data

freeze arr ?t(a mut-arr ?t) noctx trusted
	a.frozen := true
	a unsafe-as-arr

noctx-at ?t(a mut-arr ?t, index nat) trusted noctx
	hard-assert: index < a.size
	a.data + index deref

at ?t(a mut-arr ?t, index nat) trusted
	assert: index < a.size
	a noctx-at index

copy-data-from void(to ptr ?t, from ptr ?t, len nat) unsafe
	when
		len zero?
			pass
		else
			to set: from deref
			| TODO: should be able to infer type arguments
			to.incr copy-data-from<?t> from.incr, len.decr

add void(a mut-arr ?t, value ?t) trusted
	when
		a.size == a.capacity
			| Allocate a bigger one
			old-data = a.data
			a.capacity := a.size.zero? if: four, a.size * two
			a.data := uninitialized-data<?t>: a.capacity
			a.data copy-data-from old-data, a.size
		else
			pass
	a.size < a.capacity assert
	(a.data + a.size) set value
	a.size := a.size incr

make-arr arr ?t(size nat, f fun1 ?t nat)
	size make-mut-arr f freeze

make-mut-arr mut-arr ?t(size nat, f fun1 ?t nat) trusted
	res = uninitialized-mut-arr<?t>: size
	zero to size each \i
		res set-at: i, f call i
	res

to-mut-arr mut-arr ?t(a arr ?t)
	a.size make-mut-arr<?t> \i
		a at i

| Currently only used to implement print-sync, so don't worry about varargs
| TODO: 'summon'
printf void(format c-str, sz nat, data ptr char) unsafe extern

print-sync void(s str) summon trusted noctx
	printf: "%.*s\n\0".data, s.size, s.data

debug-print void(s str) trusted noctx
	printf: "%.*s\n\0".data, s.size, s.data

| Used to make code run after the actor's next step. Equivalent to `sleep 0`.
delay fut void() noctx
	pass

to-str str(b bool)
	b if "true", "false"

to-str str(n nat)
	when
		n == 0
			"0"
		n == 1
			"1"
		n == 2
			"2"
		n == 3
			"3"
		n == 4
			"4"
		n == 5
			"5"
		n == 6
			"6"
		n == 7
			"7"
		n == 8
			"8"
		n == 9
			"9"
		else
			hi = to-str: n / ten
			lo = to-str: n mod ten
			hi + lo

to-str str(n nat32)
	n.to-nat to-str

to-str str(n nat16)
	n.to-nat to-str

to-str str(i int)
	a = i.abs to-str
	| TODO: string interpolation
	i.negative? if ("-" + a), a

to-str str(i int32)
	i.to-int to-str

to-str str(i int16)
	i.to-int to-str


region dict

key-value-pair<?k, ?v> record
	key ?k
	value ?v

dict<?k, ?v> record
	keys arr ?k
	values arr ?v

empty-dict dict ?k ?v()
	| TODO: should be able to infer type arguments
	new empty-arr<?k>, empty-arr<?v>

mut-dict<?k, ?v> record mut
	keys mut-arr ?k
	values mut-arr ?v

empty-mut-dict mut-dict ?k ?v()
	| TODO: should be able to infer type arguments -- worked when there was only one field...
	new new-mut-arr<?k>, new-mut-arr<?v>

unsafe-as-dict dict ?k ?v(m mut-dict ?k ?v) unsafe
	new m.keys.unsafe-as-arr, m.values.unsafe-as-arr

freeze dict ?k ?v(m mut-dict ?k ?v)
	new m.keys.freeze, m.values.freeze

get-recursive<?k, ?v> opt ?v(keys arr ?k, values arr ?v, idx nat, key ?k)
	when
		idx == keys.size
			none
		key ==: keys at idx
			values at idx some
		else
			| TODO: should not need to provide type arguments!
			get-recursive<?k, ?v>: keys, values, idx.incr, key

get opt ?v(d dict ?k ?v, key ?k) trusted
	| TODO: should not need to provide type arguments
	get-recursive<?k, ?v>: d.keys, d.values, 0, key

get opt ?v(d mut-dict ?k ?v, key ?k) trusted
	d.unsafe-as-dict get key

at ?v(d dict ?k ?v, key ?k)
	match d get key
		none
			todo
		some s
			s.value


at ?v(d mut-dict ?k ?v, key ?k) trusted
	d.unsafe-as-dict at key

has? bool(d dict ?k ?v, key ?k)
	d get key has?

has? bool(d mut-dict ?k ?v, key ?k) trusted
	d.unsafe-as-dict has? key

add void(m mut-dict ?k ?v, key ?k, value ?v)
	forbid: m has? key
	m.keys add key
	m.values add value

map arr ?out(a arr ?in, mapper fun1 ?out ?in) trusted
	out = uninitialized-mut-arr<?out>: a.size
	zero to a.size each \i
		out set-at: i, mapper call: a at i
	out freeze

map-values dict ?k ?v-out(d dict ?k ?v-in, mapper fun1 ?v-out ?v-in)
	new-values = d.values map mapper
	new d.keys, new-values


region cell

cell<?t> record mut
	value mut ?t

new-cell cell ?t(value ?t)
	new value

get ?t(c cell ?t)
	c.value

set void(c cell ?t, v ?t)
	c.value := v

swap ?t(c cell ?t, v ?t)
	res = c get
	c set v
	res

| TODO: GENERIC
get-and-incr nat(c cell nat)
	res = c get
	c set: res incr
	res

cell-incr void(c cell nat)
	c.get-and-incr drop

cell-add void(c cell nat, n nat)
	c set: c.get + n

region iterator

| TODO: ALIAS
iterator<?t> record mut
	get-next fun0 opt<?t>

next opt ?t(i iterator ?t)
	i.get-next call

| Iterator that can be started over from the beginning.
stream<?t> record mut
	get-iter fun0 iterator<?t>

iter iterator ?t(s stream ?t)
	s.get-iter call

iter<?t, ?e> spec
	iter iterator ?e(t ?t)

to-stream<?t, ?e> stream ?e(t ?t) iter<?t, ?e>
	new {t iter}

region range

range-nat record
	| lo inclusive, hi exclusive
	lo nat
	hi nat

iter iterator nat(r range-nat)
	n = r.lo new-cell<nat>
	new \
		when
			n.get == r.hi
				none
			else
				n.get-and-incr some

to range-nat(lo nat, hi nat)
	lo <= hi assert
	new lo, hi

empty? bool(r range-nat) noctx
	r.lo == r.hi

tail range-nat(r range-nat)
	r.empty? forbid
	r.lo.incr to r.hi

each void(s stream ?t, f fun1 void ?t)
	s.iter each-recur f

each void(r range-nat, f fun1 void nat)
	r.iter each-recur f

each-recur void(i iterator ?t, f fun1 void ?t)
	match i next
		none
			pass
		some s
			f call s.value
			i each-recur f

each void(a arr ?t, f fun1 void ?t)
	when
		a empty?
			pass
		else
			f call a.first
			a.tail each f

each void(a mut-arr ?t, f fun1 void ?t) trusted
	was-frozen = a.frozen
	a.frozen := true
	a.temp-as-arr each f
	a.frozen := was-frozen

each-with-index void(a arr ?t, f fun2 void ?t nat)
	a each-with-index-recur f, zero

each-with-index-recur void(a arr ?t, f fun2 void ?t nat, n nat)
	when
		n == a.size
			pass
		else
			f call (a at n), n
			a each-with-index-recur f, n.incr


filter stream ?t(in stream ?t, pred fun1 bool ?t)
	new \
		itr = in iter
		new {itr filter-helper pred}

filter-helper opt ?t(i iterator ?t, pred fun1 bool ?t)
	match i next
		none
			none
		some s
			v = s.value
			when
				pred call v
					v some
				else
					| This one didn't satisfy the predicate, but keep trying until we get one or each the end
					i filter-helper pred

| TODO: GENERIC
sum nat(t ?t) iter<?t, nat>
	t.iter sum-helper

sum-helper nat(i iterator nat)
	match i.next
		none
			zero
		some s
			s.value + i.sum-helper


region atomic

atomic-bool record force-sendable
	value mut bool

new-atomic-bool by-val atomic-bool() noctx
	new false

| TODO: works on any primitive type, not just bool
compare-exchange-strong bool(value-ptr ptr bool, expected-ptr ptr bool, desired bool) noctx builtin

try-change bool(a atomic-bool, old-value bool) noctx trusted
	a.value.ptr-to compare-exchange-strong old-value.ptr-to, old-value.not

try-set bool(a atomic-bool) noctx
	a try-change false

try-unset bool(a atomic-bool) noctx
	a try-change true

must-unset void(a atomic-bool) noctx unsafe
	did-unset = a try-unset
	did-unset hard-assert

lock record sendable
	by-ref
	| Storing this by-val to avoid needing allocations.
	| User should prefer to store the lock by-val too, and only pass by-ref
	is-locked by-val atomic-bool

new-lock by-val lock() noctx
	new new-atomic-bool

try-acquire-lock bool(l lock) noctx trusted
	l.is-locked.ref-of-val try-set

acquire-lock void(l lock) noctx unsafe
	l acquire-lock-recur zero

acquire-lock-recur void(l lock, n-tries nat) noctx unsafe
	when
		l.try-acquire-lock
			pass
		n-tries == thousand
			hard-fail: "Couldn't acquire lock after 1000 tries"
		else
			l acquire-lock-recur n-tries.noctx-incr

release-lock void(l lock) noctx unsafe
	l.is-locked.ref-of-val must-unset

with-lock ?t(l lock, f fun0 ?t) trusted
	l acquire-lock
	res = f call
	l release-lock
	res

condition record mut
	lk by-val lock
	value mut nat

new-condition by-val condition() noctx
	new new-lock, zero

broadcast void(c condition) noctx trusted
	c.lk.ref-of-val acquire-lock
	c.value := c.value noctx-incr
	c.lk.ref-of-val release-lock

last-checked alias
	nat

get-last-checked last-checked(c condition) noctx
	c.value

usleep void(micro-seconds nat) extern

| TODO:MOVE
sleep-ms-sync void(ms nat) noctx
	| TODO: wrap-mul is unsafe
	ms wrap-mul thousand usleep

wait-on void(c condition, last-checked last-checked) noctx
	when
		c.value == last-checked
			pass
		else
			hundred sleep-ms-sync


| TODO: use atomic operations for this
thread-safe-counter record mut
	lk by-val lock
	value mut nat

new-thread-safe-counter by-val thread-safe-counter() noctx
	zero new-thread-safe-counter

new-thread-safe-counter by-val thread-safe-counter(init nat) noctx
	new new-lock, init

increment void(t thread-safe-counter) noctx
	t.get-and-increment drop

get-and-increment nat(t thread-safe-counter) noctx trusted
	l = t.lk.ref-of-val
	l acquire-lock
	res = t.value
	t.value := t.value noctx-incr
	l release-lock
	res

| Returns true if the counter is now 0.
decrement bool(t thread-safe-counter) noctx
	t.get-and-decrement zero?

get-and-decrement nat(t thread-safe-counter) noctx trusted
	l = t.lk.ref-of-val
	l acquire-lock
	res = t.value
	hard-forbid: res zero?
	t.value := t.value noctx-decr
	l release-lock
	res

region runtime

global-ctx record mut
	lk by-val lock
	| TODO: mut-arr
	vats mut arr vat
	| When a thread finds no work to do, it decrements this and waits on 'may-be-work-to-do'.
	| When the last thread decrements this, it can't go to sleep!
	| But if there's no work to do, it can set 'is-shut-down' and wake up the other threads so they can shut down too.
	n-live-threads mut nat
	may-be-work-to-do by-val condition
	is-shut-down mut bool

new-global-ctx by-val global-ctx(n-threads nat) noctx
	new new-lock, empty-arr<vat>, n-threads, new-condition, false

vat-id alias
	nat
actor-id alias
	nat

vat-and-actor-id record
	vat vat-id
	actor actor-id

gc record mut
	lk by-val lock
	needs-gc mut bool
	is-doing-gc mut bool
	begin ptr byte
	next ptr byte

new-gc by-val gc() noctx
	new new-lock, false, false, null, null

try-gc-alloc opt any-ptr(gc gc, size nat) noctx trusted
	| TODO: allocate from gc memory!
	size.unmanaged-alloc-bytes some

gc-alloc any-ptr(gc gc, size nat)
	match gc try-gc-alloc size
		none
			| TODO: throw an exception on OOM
			todo
		some s
			s.value

unmanaged-alloc-bytes any-ptr(size nat) noctx unsafe
	res = size malloc
	hard-forbid: res == null
	res

unmanaged-alloc-elements ptr ?t(size-elements nat) noctx unsafe
	| TODO: wrap-mul is unsafe!
	bytes = size-elements wrap-mul size-of<?t> unmanaged-alloc-bytes
	bytes ptr-cast


task record mut
	by-val
	| Unlike a send-fun, this is stored in the vat already, so no need to store vat here too.
	| Also, the fun just returns 'void'. You can just use a fut-returning fun and drop the fut.
	| The fun runs using a ctx created from the actor-id.
	actor-id opt actor-id
	fun fun0 void



region mut-bag

| NOTE: currently this is a linked list, but we actually want to pseudorandomly take out nodes.

mut-bag-node<?t> record mut
	value ?t
	next-node mut opt mut-bag-node<?t>

| Expose construction of nodes, because it's better to do this outside of a lock
new-mut-bag-node mut-bag-node ?t(value ?t)
	new value, none

mut-bag<?t> record mut
	head mut opt mut-bag-node<?t>

new-mut-bag by-val mut-bag<?t>() noctx
	new none

add void(bag mut-bag ?t, node mut-bag-node ?t) noctx
	| TODO: insert randomly somewhere
	node.next-node := bag.head
	bag.head := node some

empty? bool(m mut-bag ?t) noctx
	m.head empty?


region vat

vat record mut
	gctx global-ctx
	id vat-id
	gc by-val gc

	| these variables are all protected by tasks-lock
	tasks-lock by-val lock
	tasks by-val mut-bag<task>
	| TODO: mut-set
	currently-running-actors by-val mut-arr<actor-id>
	| Number of threads currently performing tasks in this vat
	n-threads-running mut nat

	| not protected by tasks-lock, thread-safe on its own
	next-actor-id by-val thread-safe-counter

add-task void(v vat, t task) trusted
	| Do allocation outside of the lock
	node = t new-mut-bag-node

	v.tasks-lock.ref-of-val acquire-lock
	v.tasks.ref-of-val add node
	v.tasks-lock.ref-of-val release-lock

	v.gctx.may-be-work-to-do.ref-of-val broadcast

new-actor-id actor-id(v vat) noctx trusted
	v.next-actor-id.ref-of-val get-and-increment

new-vat by-val vat(gctx global-ctx, id vat-id, max-threads nat) noctx unsafe
	actors = max-threads new-mut-arr-by-val-with-capacity-from-unmanaged-memory<actor-id>
	new gctx, id, new-gc, new-lock, new-mut-bag, actors, zero, new-thread-safe-counter

ctx record mut
	gctx global-ctx
	vat vat
	actor-id opt actor-id
	| TODO: GC allocation context
	| TODO: exception context

new-ctx by-val ctx(gctx global-ctx, vat vat, actor-id opt actor-id) noctx
	new gctx, vat, actor-id





thread-function void(thread-id nat, gctx global-ctx) noctx unsafe
	when
		gctx is-shut-down
			| Exit. Should be no tasks left.
			gctx.lk.ref-of-val acquire-lock
			assert-vats-are-shut-down: zero, gctx.vats
			gctx.lk.ref-of-val release-lock
		else
			hard-assert: gctx.n-live-threads > zero
			| Get a task to do; or sleep.
			last-checked = gctx.may-be-work-to-do.ref-of-val get-last-checked

			match gctx choose-task
				ok ok-chosen-task
					gctx do-task ok-chosen-task.value
				err e
					when
						e.value.last-thread-out
							hard-forbid: gctx.is-shut-down
							gctx.is-shut-down := true
							| Wake up sleeping threads so they can shut down
							gctx.may-be-work-to-do.ref-of-val broadcast
						else
							gctx.may-be-work-to-do.ref-of-val wait-on last-checked


			thread-function: zero, gctx

do-task void(gctx global-ctx, chosen-task chosen-task) noctx unsafe
	vat = chosen-task.vat
	match chosen-task.task-or-gc
		none
			| Means -- do GC
			| We might have avoided doing a task because GC was running.
			| Now those tasks can be done.
			todo
			gctx.may-be-work-to-do.ref-of-val broadcast
		some some-task
			task = some-task.value
			ctx = new-ctx: gctx, vat, task.actor-id
			ctx.ref-of-val call-with-ctx task.fun
			vat.tasks-lock.ref-of-val acquire-lock
			match task.actor-id
				none
					pass
				some some-actor-id
					vat.currently-running-actors.ref-of-val noctx-must-remove-unordered some-actor-id.value
			vat.tasks-lock.ref-of-val release-lock

	| We incremented this when choosing the task.
	vat.tasks-lock.ref-of-val acquire-lock
	vat.n-threads-running := vat.n-threads-running.noctx-decr
	vat.tasks-lock.ref-of-val release-lock


task-or-gc alias
	opt task

chosen-task record mut
	by-val
	vat vat
	| If none, do GC on the vat.
	task-or-gc task-or-gc

no-chosen-task record
	by-val
	| If true, no threads are doing any work and we should exit the program.
	last-thread-out bool


choose-task result chosen-task no-chosen-task(gctx global-ctx) noctx unsafe
	gctx.lk.ref-of-val acquire-lock

	| TODO: more fair algorithm.
	| This looks for the first vat with some work to do.
	| (That is unfair as vat 0 will tend to get the most attention.)

	res = as<result<chosen-task, no-chosen-task>>: match gctx.vats choose-task-recur zero
		none
			| Did not find a task to do.
			| (Tasks may have been added concurrently;
			| this is fine as we're about to wait on a condition and will immediately wake up if so.)
			gctx.n-live-threads := gctx.n-live-threads.noctx-decr
			err: new<no-chosen-task> gctx.n-live-threads zero?
		some s
			s.value ok

	gctx.lk.ref-of-val release-lock

	res


choose-task-recur opt chosen-task(vats arr vat, i nat) noctx unsafe
	when
		i == vats.size
			none
		else
			vat = vats noctx-at i
			match vat choose-task-in-vat
				none
					vats choose-task-recur i.noctx-incr
				some s
					some: new<chosen-task> vat, s.value



| some(none) means: do a GC
choose-task-in-vat opt task-or-gc(vat vat) noctx unsafe
	vat.tasks-lock.ref-of-val acquire-lock

	res = as<opt<task-or-gc>>: when
		| TODO: ref-of-val should be unnecessary for property access?
		vat.gc.ref-of-val.needs-gc
			when
				vat.n-threads-running zero?
					| do GC
					none some
				else
					| do nothing -- a thread is running on this vat
					| we can't do a GC now, but don't want to start a new task either
					| because that would block GC
					none
		else
			match vat find-and-remove-first-doable-task
				none
					| No tasks to run
					none
				some s
					s.value.some some

	when
		res empty?
			pass
		else
			vat.n-threads-running := vat.n-threads-running.noctx-incr

	vat.tasks-lock.ref-of-val release-lock

	res


task-and-nodes record mut
	by-val
	task task
	nodes opt mut-bag-node<task>

find-and-remove-first-doable-task opt task(vat vat) noctx unsafe
	tasks = vat.tasks.ref-of-val
	res = vat find-and-remove-first-doable-task-recur tasks.head
	match res
		none
			none
		some s
			tasks.head := s.value.nodes
			s.value.task some

find-and-remove-first-doable-task-recur opt task-and-nodes(vat vat, opt-node opt mut-bag-node<task>) noctx unsafe
	match opt-node
		none
			none
		some s
			node = s.value
			task = node.value
			task-ok = match task.actor-id
				none
					| No actor id means always safe to run
					true
				some ss
					actor = ss.value
					| Can't do this task if the actor is busy.
					| (If we don't have space to expand currently-running-actors,
					| shouldn't be starting a new task anyway.)
					actors = vat.currently-running-actors ref-of-val
					when
						actors contains actor
							false
						else
							actors push-capacity-must-be-sufficient actor
							true
			when
				task-ok
					| Extract this task (return just its tail)
					some: new<task-and-nodes> task, node.next-node
				else
					match vat find-and-remove-first-doable-task-recur node.next-node
						none
							none
						some ss
							tn = ss.value as<task-and-nodes>
							node.next-node := tn.nodes
							some: new<task-and-nodes> tn.task, node some

assert-vats-are-shut-down void(i nat, vats arr vat) noctx unsafe
	when
		i == vats.size
			pass
		else
			vat = vats noctx-at i

			vat.tasks-lock.ref-of-val acquire-lock
			hard-forbid: vat.gc.ref-of-val needs-gc
			hard-assert: vat.n-threads-running zero?
			hard-assert: vat.tasks.ref-of-val empty?
			vat.tasks-lock.ref-of-val release-lock

			assert-vats-are-shut-down: i.noctx-incr, vats
