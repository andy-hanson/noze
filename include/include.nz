region basic

| Unrecoverable assertion failure
hard-fail ?t(reason str) unsafe noctx builtin

fail ?t(reason str)
	todo

todo ?t() trusted noctx
	| TODO: soft-fail, remove 'trusted' above
	hard-fail: "TODO"

region system

| This will be a large struct
ctx record
	a nat64
	b nat64
	c nat64

by-val<?t> builtin

| Unsafe because the ref will only be valid temporarily!
ref-of-val ?t(b by-val ?t) unsafe noctx builtin

| Since this fun is not marked 'noctx', it simply returns the ctx that already exists.
get-ctx ctx() unsafe builtin

void builtin
byte builtin

| NOTE: if ?t is a reference type, ptr<?t> is a pointer to a pointer to ?t
ptr<?t> builtin
deref ?t(p ptr ?t) unsafe noctx builtin
set void(p ptr ?t, value ?t) unsafe noctx builtin

null ptr ?t() unsafe noctx builtin

any-ptr alias
	ptr byte

is-reference-type<?t> bool() unsafe noctx builtin
size-of<?t> nat64() unsafe noctx builtin

size-or-pointer-size<?t> nat64() unsafe noctx
	when
		is-reference-type<?t>
			size-of<ptr<void>>
		else
			size-of<?t>

ptr-cast ptr ?out(p ptr ?in) unsafe noctx builtin

+ ptr ?t(p ptr ?t, offset nat64) unsafe noctx builtin
- ptr ?t(p ptr ?t, offset nat64) unsafe noctx builtin

malloc any-ptr(size nat64) unsafe extern

allocate-bytes any-ptr(size nat64) unsafe
	| TODO: Allocate from ctx (Use 'get-ctx' builtin fun)
	| Note: malloc always returns aligned memory (max_align_t)
	malloc: size

region comparison

less record
equal record
greater record
comparison union
	less
	equal
	greater

<=> comparison(a ?t, b ?t) noctx builtin

== bool(a ?t, b ?t) noctx
	match a <=> b
		less
			false
		equal
			true
		greater
			false

| != bool(a ?t, b ?t)
|	a == b not

< bool(a ?t, b ?t) noctx
	match a <=> b
		less
			true
		equal
			false
		greater
			false

<= bool(a ?t, b ?t) noctx
	b < a not

> bool(a ?t, b ?t) noctx
	a <= b not

>= bool(a ?t, b ?t) noctx
	a < b not

min ?t(a ?t, b ?t) noctx
	(a < b) if a, b

max ?t(a ?t, b ?t) noctx
	(a > b) if a, b

region str

char builtin
str alias
	arr char
c-str alias
	ptr char

literal char(s str) noctx
	s noctx-at zero

region bool

bool builtin
false bool() noctx builtin
true bool() noctx builtin
not bool(a bool) noctx builtin
| Note: this should be lazily evaluated
and bool(a bool, b bool) noctx builtin
or bool(a bool, b bool) noctx builtin
nand bool(a bool, b bool) noctx builtin
nor bool(a bool, b bool) noctx builtin
| Only one of 'if-true' and 'if-false' arguments will be evaluated
if ?t(cond bool, if-true ?t, if-false ?t) noctx builtin

region Fun

| Pointer to a function with no arguments (not even ctx)
fun-ptr0<?r> builtin
fun-ptr1<?r, ?p0> builtin
fun-ptr2<?r, ?p0, ?p1> builtin
fun-ptr3<?r, ?p0, ?p1, ?p2> builtin
fun-ptr4<?r, ?p0, ?p1, ?p2, ?p3> builtin

| A fun is two pointers -- one to the fun pointer, one to the closure.
| TODO: point to the vtable, and have vtable also store layout information
| A remote-fun is a fun plus a vat and actor id.
fun0<?r> record mut
	fun-ptr fun-ptr2 ?r ctx any-ptr
	closure any-ptr
fun1<?r, ?p0> record mut
	fun-ptr fun-ptr3 ?r ctx any-ptr ?p0
	closure any-ptr
fun2<?r, ?p0, ?p1> record mut
	fun-ptr fun-ptr4 ?r ctx any-ptr ?p0 ?p1
	closure any-ptr

| TODO: not builtin
remote-fun0<?r> builtin mut
remote-fun1<?r, ?p0> builtin mut
remote-fun2<?r, ?p0, ?p1> builtin mut

call ?r(f fun-ptr0 ?r) noctx builtin
call ?r(f fun-ptr1 ?r ?p0, p0 ?p0) noctx builtin
call ?r(f fun-ptr2 ?r ?p0 ?p1, p0 ?p0, p1 ?p1) noctx builtin
call ?r(f fun-ptr3 ?r ?p0 ?p1 ?p2, p0 ?p0, p1 ?p1, p2 ?p2) noctx builtin
call ?r(f fun-ptr4 ?r ?p0 ?p1 ?p2 ?p3, p0 ?p0, p1 ?p1, p2 ?p2, p3 ?p3) noctx builtin

| Note: this is the implementation for a dynamic call.
| But the compiler may call the function dynamically instead
call ?r(f fun0 ?r) trusted
	get-ctx call-with-ctx f

call-with-ctx ?r(c ctx, f fun0 ?r) noctx trusted
	f.fun-ptr call c, f.closure

call ?r(f fun1 ?r ?p0, p0 ?p0) trusted
	get-ctx call-with-ctx f, p0

call-with-ctx ?r(c ctx, f fun1 ?r ?p0, p0 ?p0) noctx trusted
	f.fun-ptr call c, f.closure, p0

call ?r(f fun2 ?r ?p0 ?p1, p0 ?p0, p1 ?p1) trusted
	get-ctx call-with-ctx f, p0, p1

call-with-ctx ?r(c ctx, f fun2 ?r ?p0 ?p1, p0 ?p0, p1 ?p1) noctx trusted
	f.fun-ptr call c, f.closure, p0, p1

call fut ?r(f remote-fun0 ?r)
	todo

call fut ?r(f remote-fun1 ?r ?p0, p0 ?p0)
	todo

call fut ?r(f remote-fun2 ?r ?p0 ?p1, p0 ?p0, p1 ?p1)
	todo

region Arithmetic

nat64 builtin
int64 builtin
float64 builtin

to-nat64 nat64(i int64) noctx builtin
to-int64 int64(n nat64) noctx builtin

wrapping-add nat64(a nat64, b nat64) noctx builtin
wrapping-sub nat64(a nat64, b nat64) noctx builtin
wrapping-mul nat64(a nat64, b nat64) noctx builtin
unsafe-div nat64(a nat64, b nat64) unsafe noctx builtin
zero nat64() noctx builtin
one nat64() noctx builtin
two nat64() noctx
	one incr
three nat64() noctx
	two incr
four nat64() noctx
	three incr
five nat64() noctx
	four incr
six nat64() noctx
	five incr
seven nat64() noctx
	six incr
eight nat64() noctx
	seven incr
nine nat64() noctx
	eight incr
ten nat64() noctx
	nine incr

wrapping-add int64(a int64, b int64) noctx builtin
wrapping-sub int64(a int64, b int64) noctx builtin
wrapping-mul int64(a int64, b int64) noctx builtin
unsafe-div int64(a int64, b int64) unsafe noctx builtin
zero int64() noctx builtin
one int64() noctx builtin
two int64() noctx
	one incr
three int64() noctx
	two incr
four int64() noctx
	three incr
five int64() noctx
	four incr
six int64() noctx
	five incr
seven int64() noctx
	six incr
eight int64() noctx
	seven incr
nine int64() noctx
	eight incr
ten int64() noctx
	nine incr

incr nat64(n nat64) noctx
	| TODO: assert: n != max-value
	n wrapping-add one

incr int64(i int64) noctx
	| TODO: assert: i != max-value
	i wrapping-add one

incr ptr ?t(p ptr ?t) unsafe noctx
	p + one

decr nat64(n nat64)
	n - 1

| decr int64(i int64)
|	i - 1

decr ptr ?t(p ptr ?t) unsafe noctx
	p - one

+ nat64(a nat64, b nat64)
	| TODO: asserts for safety
	a wrapping-add b
- nat64(a nat64, b nat64)
	assert: a > b
	a wrapping-sub b
* nat64(a nat64, b nat64)
	| TODO: asserts for safety
	a wrapping-mul b
/ nat64(a nat64, b nat64) trusted
	forbid: b == 0
	a unsafe-div b

+ float64(a float64, b float64) noctx builtin
- float64(a float64, b float64) noctx builtin
* float64(a float64, b float64) noctx builtin
unsafe-div float64(a float64, b float64) unsafe noctx builtin
zero float64() noctx builtin
one float64() noctx builtin

char-to-nat64 nat64(c char) noctx
	when
		c == "0"
			zero
		c == "1"
			one
		c == "2"
			two
		c == "3"
			three
		c == "4"
			four
		c == "5"
			five
		c == "6"
			six
		c == "7"
			seven
		c == "8"
			eight
		c == "9"
			nine
		else
			todo

literal nat64(s str) noctx
	l = s.size
	when
		l == one
			char-to-nat64: s noctx-at zero
		else
			todo

region Util

pass void() noctx builtin
pass fut void() noctx builtin
drop void(t ?t)
	pass

hard-assert void(condition bool) unsafe noctx
	when
		condition
			pass
		else
			"Assertion failed!" hard-fail

assert void(condition bool)
	when
		condition
			pass
		else
			"Assertion failed!" fail

forbid void(condition bool)
	condition.not assert

hard-assert-unreachable ?t() unsafe noctx
	"should be unreachable" hard-fail

assert-unreachable ?t()
	"should be unreachable" fail

some<?t> record
	value ?t
none record
opt<?t> union
	some<?t>
	none

empty? bool(a opt ?t) noctx
	match a
		some s
			false
		none n
			true

has? bool(a opt ?t) noctx
	a.empty? not

as ?t(value ?t) noctx builtin
as-non-const ?t(value ?t) noctx builtin

region fut

fut<?t> builtin sendable
resolved fut ?t(value ?t)
	todo
then fut ?out(a fut ?in, cb remote-fun1 ?out ?in)
	todo
join fut ?out(a fut ?in0, b fut ?in1, cb remote-fun2 ?out ?in0 ?in1)
	todo

region arr

| NOTE: this is not a normal record, compiler treats it specially
arr<?t> record
	size nat64
	data ptr ?t

empty-arr arr ?t() trusted
	| TODO: should be able to infer type argument to null!
	new zero, null<?t>

noctx-at ?t(a arr ?t, index nat64) trusted noctx
	hard-assert: index < a.size
	a.data + index deref

at ?t(a arr ?t, index nat64) trusted
	assert: index < a.size
	a.data + index deref

| NOTE: this is not a normal record, compiler treats it specially
mut-arr<?t> record
	mut frozen bool
	| Number of *initialized* elements.
	| But 'uninitialized-mut-arr' sets 'size' and doesn't initialize!
	mut size nat64
	mut capacity nat64
	mut data ptr ?t

uninitialized-data ptr ?t(size nat64) unsafe
	bptr = allocate-bytes: size wrapping-mul size-of<?t>
	bptr ptr-cast<?t, byte>

uninitialized-mut-arr mut-arr ?t(size nat64) unsafe
	new false, size, size, uninitialized-data<?t>: size

empty-mut-arr mut-arr ?t() trusted
	uninitialized-mut-arr<?t>: 0

set-at void(a mut-arr ?t, index nat64, value ?t) trusted
	assert: index < a.size
	(a.data + index) set value

| Unsafe as this does *not* freeze it!
unsafe-as-arr arr ?t(a mut-arr ?t) unsafe noctx
	new a.size, a.data

freeze arr ?t(a mut-arr ?t) noctx trusted
	a.frozen := true
	a unsafe-as-arr

at ?t(a mut-arr ?t, index nat64) trusted
	when
		index < a.size
			a.data + index deref
		else
			fail: "bad mut-arr index"

copy-data-from void(to ptr ?t, from ptr ?t, len nat64) unsafe
	when
		len == 0
			pass
		else
			to set: from deref
			| TODO: should be able to infer type arguments
			to.incr copy-data-from<?t> from.incr, len.decr

add void(a mut-arr ?t, value ?t) trusted
	when
		a.size == a.capacity
			| Allocate a bigger one
			old-data = a.data
			a.capacity := a.size == 0 if: 4, a.size * 2
			a.data := uninitialized-data<?t>: a.capacity
			a.data copy-data-from old-data, a.size
		else
			pass
	a.size < a.capacity assert
	(a.data + a.size) set value
	a.size := a.size incr

each-in-range void(lo nat64, hi nat64, f fun1 void nat64)
	assert: lo <= hi
	when
		lo == hi
			pass
		else
			f call lo
			each-in-range: lo.incr, hi, f

make-arr arr ?t(size nat64, f fun1 ?t nat64)
	size make-mut-arr f freeze

make-mut-arr mut-arr ?t(size nat64, f fun1 ?t nat64) trusted
	res = uninitialized-mut-arr<?t>: size
	each-in-range: zero, size, \i
		res set-at: i, f call i
	res

to-mut-arr mut-arr ?t(a arr ?t)
	a.size make-mut-arr<?t> \i
		a at i

| Currently only used to implement print-sync, so don't worry about varargs
printf void(format c-str, sz nat64, data ptr char) summon unsafe extern

print-sync void(s str) summon trusted noctx
	printf: "%.*s\n\0".data, s.size, s.data

| Used to make code run after the actor's next step. Equivalent to `sleep 0`.
delay fut void() noctx
	pass

to-str str(n nat64)
	when
		n == 0
			"0"
		n == 1
			"1"
		n == 2
			"2"
		n == 3
			"3"
		n == 4
			"4"
		n == 5
			"5"
		n == 6
			"6"
		n == 7
			"7"
		n == 8
			"8"
		n == 9
			"9"
		else
			todo


region dict

key-value-pair<?k, ?v> record
	key ?k
	value ?v

dict<?k, ?v> record
	keys arr ?k
	values arr ?v

empty-dict dict ?k ?v()
	| TODO: should be able to infer type arguments
	new empty-arr<?k>, empty-arr<?v>

mut-dict<?k, ?v> record
	keys mut-arr ?k
	values mut-arr ?v

empty-mut-dict mut-dict ?k ?v()
	| TODO: should be able to infer type arguments -- worked when there was only one field...
	new empty-mut-arr<?k>, empty-mut-arr<?v>

unsafe-as-dict dict ?k ?v(m mut-dict ?k ?v) unsafe
	new m.keys.unsafe-as-arr, m.values.unsafe-as-arr

freeze dict ?k ?v(m mut-dict ?k ?v)
	new m.keys.freeze, m.values.freeze

get-recursive<?k, ?v> opt ?v(keys arr ?k, values arr ?v, idx nat64, key ?k)
	when
		idx == keys.size
			new<none>
		key ==: keys at idx
			new<some<?v>> values at idx
		else
			| TODO: should not need to provide type arguments!
			get-recursive<?k, ?v>: keys, values, idx.incr, key

get opt ?v(d dict ?k ?v, key ?k) trusted
	| TODO: should not need to provide type arguments
	get-recursive<?k, ?v>: d.keys, d.values, 0, key

get opt ?v(d mut-dict ?k ?v, key ?k) trusted
	d.unsafe-as-dict get key

at ?v(d dict ?k ?v, key ?k)
	match d get key
		some s
			s.value
		none
			todo

at ?v(d mut-dict ?k ?v, key ?k) trusted
	d.unsafe-as-dict at key

has? bool(d dict ?k ?v, key ?k)
	d get key has?

has? bool(d mut-dict ?k ?v, key ?k) trusted
	d.unsafe-as-dict has? key

add void(m mut-dict ?k ?v, key ?k, value ?v)
	forbid: m has? key
	m.keys add key
	m.values add value

map arr ?out(a arr ?in, mapper fun1 ?out ?in) trusted
	out = uninitialized-mut-arr<?out>: a.size
	each-in-range: zero, a.size, \i
		out set-at: i, mapper call: a at i
	out freeze

map-values dict ?k ?v-out(d dict ?k ?v-in, mapper fun1 ?v-out ?v-in)
	new-values = d.values map mapper
	new d.keys, new-values
