region basic

| Unrecoverable assertion failure
hard-fail ?t(reason str) noctx unsafe builtin

fail ?t(reason str)
	todo

todo ?t() trusted noctx
	| TODO: soft-fail, remove 'trusted' above
	hard-fail: "TODO"

region system

by-val<?t> builtin

| Unsafe because the ref will only be valid temporarily!
ref-of-val ?t(b by-val ?t) noctx unsafe builtin

| This forces something to be stack-allocated.
| WARN: If '?t' is a reference type already, this is a pointer to a pointer!
ptr-to ptr ?t(t ?t) noctx unsafe builtin

| Since this fun is not marked 'noctx', it simply returns the ctx that already exists.
get-ctx ctx() unsafe builtin

void builtin
byte builtin

| NOTE: if ?t is a reference type, ptr<?t> is a pointer to a pointer to ?t
ptr<?t> builtin
deref ?t(p ptr ?t) noctx unsafe builtin
set void(p ptr ?t, value ?t) noctx unsafe builtin

null ptr ?t() noctx builtin

any-ptr alias
	ptr byte

is-reference-type?<?t> bool() noctx unsafe builtin
size-of<?t> nat64() noctx unsafe builtin

size-or-pointer-size<?t> nat64() noctx unsafe
	when
		is-reference-type?<?t>
			size-of<ptr<void>>
		else
			size-of<?t>

ptr-cast ptr ?out(p ptr ?in) noctx unsafe builtin

+ ptr ?t(p ptr ?t, offset nat64) noctx unsafe builtin
- ptr ?t(p ptr ?t, offset nat64) noctx unsafe builtin

malloc any-ptr(size nat64) unsafe extern

allocate-bytes any-ptr(size nat64) unsafe
	| TODO: Allocate from ctx (Use 'get-ctx' builtin fun)
	| Note: malloc always returns aligned memory (max_align_t)
	malloc: size

region comparison

less record
equal record
greater record
comparison union
	less
	equal
	greater

<=> comparison(a ?t, b ?t) noctx builtin

== bool(a ?t, b ?t) noctx
	match a <=> b
		less
			false
		equal
			true
		greater
			false

| != bool(a ?t, b ?t)
|	a == b not

< bool(a ?t, b ?t) noctx
	match a <=> b
		less
			true
		equal
			false
		greater
			false

<= bool(a ?t, b ?t) noctx
	b < a not

> bool(a ?t, b ?t) noctx
	a <= b not

>= bool(a ?t, b ?t) noctx
	a < b not

min ?t(a ?t, b ?t) noctx
	(a < b) if a, b

max ?t(a ?t, b ?t) noctx
	(a > b) if a, b

region str

char builtin
str alias
	arr char
c-str alias
	ptr char

literal char(s str) noctx
	s noctx-at zero

region bool

bool builtin
false bool() noctx builtin
true bool() noctx builtin
not bool(a bool) noctx builtin
| Note: this should be lazily evaluated
and bool(a bool, b bool) noctx builtin
or bool(a bool, b bool) noctx builtin
nand bool(a bool, b bool) noctx builtin
nor bool(a bool, b bool) noctx builtin
| Only one of 'if-true' and 'if-false' arguments will be evaluated
if ?t(cond bool, if-true ?t, if-false ?t) noctx builtin

region Fun

| Pointer to a function with no arguments (not even ctx)
fun-ptr0<?r> builtin
fun-ptr1<?r, ?p0> builtin
fun-ptr2<?r, ?p0, ?p1> builtin
fun-ptr3<?r, ?p0, ?p1, ?p2> builtin
fun-ptr4<?r, ?p0, ?p1, ?p2, ?p3> builtin

| A fun is two pointers -- one to the fun pointer, one to the closure.
| TODO: point to the vtable, and have vtable also store layout information
| A remote-fun is a fun plus a vat and actor id.
fun0<?r> record mut
	fun-ptr fun-ptr2 ?r ctx any-ptr
	closure any-ptr
fun1<?r, ?p0> record mut
	fun-ptr fun-ptr3 ?r ctx any-ptr ?p0
	closure any-ptr
fun2<?r, ?p0, ?p1> record mut
	fun-ptr fun-ptr4 ?r ctx any-ptr ?p0 ?p1
	closure any-ptr

| TODO: not builtin
remote-fun0<?r> builtin mut
remote-fun1<?r, ?p0> builtin mut
remote-fun2<?r, ?p0, ?p1> builtin mut

call ?r(f fun-ptr0 ?r) noctx builtin
call ?r(f fun-ptr1 ?r ?p0, p0 ?p0) noctx builtin
call ?r(f fun-ptr2 ?r ?p0 ?p1, p0 ?p0, p1 ?p1) noctx builtin
call ?r(f fun-ptr3 ?r ?p0 ?p1 ?p2, p0 ?p0, p1 ?p1, p2 ?p2) noctx builtin
call ?r(f fun-ptr4 ?r ?p0 ?p1 ?p2 ?p3, p0 ?p0, p1 ?p1, p2 ?p2, p3 ?p3) noctx builtin

| Note: this is the implementation for a dynamic call.
| But the compiler may call the function dynamically instead
call ?r(f fun0 ?r) trusted
	get-ctx call-with-ctx f

call-with-ctx ?r(c ctx, f fun0 ?r) noctx trusted
	f.fun-ptr call c, f.closure

call ?r(f fun1 ?r ?p0, p0 ?p0) trusted
	get-ctx call-with-ctx f, p0

call-with-ctx ?r(c ctx, f fun1 ?r ?p0, p0 ?p0) noctx trusted
	f.fun-ptr call c, f.closure, p0

call ?r(f fun2 ?r ?p0 ?p1, p0 ?p0, p1 ?p1) trusted
	get-ctx call-with-ctx f, p0, p1

call-with-ctx ?r(c ctx, f fun2 ?r ?p0 ?p1, p0 ?p0, p1 ?p1) noctx trusted
	f.fun-ptr call c, f.closure, p0, p1

call fut ?r(f remote-fun0 ?r)
	todo

call fut ?r(f remote-fun1 ?r ?p0, p0 ?p0)
	todo

call fut ?r(f remote-fun2 ?r ?p0 ?p1, p0 ?p0, p1 ?p1)
	todo

region Arithmetic

nat64 builtin
int64 builtin
float64 builtin

| UB for negative numbers
unsafe-to-nat64 nat64(i int64) noctx builtin

| UB for positive numbers >= 2 ** 63
unsafe-to-int64 int64(n nat64) noctx builtin

wrapping-add nat64(a nat64, b nat64) noctx builtin
wrapping-sub nat64(a nat64, b nat64) noctx builtin
wrapping-mul nat64(a nat64, b nat64) noctx builtin
unsafe-div nat64(a nat64, b nat64) noctx unsafe builtin
unsafe-mod nat64(a nat64, b nat64) noctx unsafe builtin
zero nat64() noctx builtin
one nat64() noctx builtin
two nat64() noctx
	one incr
three nat64() noctx
	two incr
four nat64() noctx
	three incr
five nat64() noctx
	four incr
six nat64() noctx
	five incr
seven nat64() noctx
	six incr
eight nat64() noctx
	seven incr
nine nat64() noctx
	eight incr
ten nat64() noctx
	nine incr
hundred nat64() noctx
	ten wrapping-mul ten
thousand nat64() noctx
	hundred wrapping-mul ten

wrapping-add int64(a int64, b int64) noctx builtin
wrapping-sub int64(a int64, b int64) noctx builtin
wrapping-mul int64(a int64, b int64) noctx builtin
unsafe-div int64(a int64, b int64) noctx unsafe builtin
zero int64() noctx builtin
one int64() noctx builtin
neg-one int64() noctx
	zero wrapping-sub one
two int64() noctx
	one incr
three int64() noctx
	two incr
four int64() noctx
	three incr
five int64() noctx
	four incr
six int64() noctx
	five incr
seven int64() noctx
	six incr
eight int64() noctx
	seven incr
nine int64() noctx
	eight incr
ten int64() noctx
	nine incr

incr nat64(n nat64) noctx
	| TODO: assert: n != max-value
	n wrapping-add one

incr int64(i int64) noctx
	| TODO: assert: i != max-value
	i wrapping-add one

incr ptr ?t(p ptr ?t) noctx unsafe
	p + one

decr-noctx nat64(n nat64) noctx unsafe
	hard-forbid: n == zero
	n wrapping-sub one

decr nat64(n nat64)
	forbid: n == zero
	n wrapping-sub one

| decr int64(i int64)
|	i - 1

decr ptr ?t(p ptr ?t) noctx unsafe
	p - one

+ nat64(a nat64, b nat64)
	res = a wrapping-add b
	assert: res >= a and: res >= b
	res
- nat64(a nat64, b nat64)
	assert: a > b
	a wrapping-sub b
* nat64(a nat64, b nat64)
	| TODO: better safety check
	when
		a == zero or: b == zero
			zero
		else
			res = a wrapping-mul b
			assert: res / b == a
			assert: res / a == b
			res
/ nat64(a nat64, b nat64) trusted
	forbid: b == zero
	| TODO: doing this silly thing to avoid evaluating a / b as a constant
	when
		b == 0
			seven
		else
			a unsafe-div b

mod nat64(a nat64, b nat64) trusted
	forbid: b == zero
	a unsafe-mod b

+ int64(a int64, b int64)
	| TODO: better safety check
	assert: a > -999
	assert: a < 999
	assert: b > -999
	assert: b < 999
	a wrapping-add b

- int64(a int64, b int64)
	| TODO: better safety check
	assert: a > -999
	assert: a < 999
	assert: b > -999
	assert: b < 999
	a wrapping-sub b
* int64(a int64, b int64)
	assert: a > -999
	assert: a < 999
	assert: b > -999
	assert: b < 999
	a wrapping-mul b
/ int64(a int64, b int64) trusted
	forbid: b == zero
	| If a is the smallest int and b is -1, result is UB
	| TODO: better safety check
	assert: a > -999
	a unsafe-div b

to-int64 int64(n nat64)
	| assert: n < (32 pow2)
	assert: n < 9999
	n unsafe-to-int64

to-nat64 nat64(i int64)
	forbid: i.negative?
	i unsafe-to-nat64

negative? bool(i int64)
	i < zero

neg int64(i int64)
	i * neg-one

neg int64(n nat64)
	n.to-int64 neg

abs nat64(i int64)
	i-abs = i.negative? if i.neg, i
	i-abs to-nat64

mod nat64(a int64, b nat64)
	forbid: b == zero
	when
		a negative?
			x = a.abs mod b
			x == b if 0, b - x
		else
			a.to-nat64 mod b

+ float64(a float64, b float64) noctx builtin
- float64(a float64, b float64) noctx builtin
* float64(a float64, b float64) noctx builtin
unsafe-div float64(a float64, b float64) noctx unsafe builtin
zero float64() noctx builtin
one float64() noctx builtin

char-to-nat64 nat64(c char) noctx
	when
		c == "0"
			zero
		c == "1"
			one
		c == "2"
			two
		c == "3"
			three
		c == "4"
			four
		c == "5"
			five
		c == "6"
			six
		c == "7"
			seven
		c == "8"
			eight
		c == "9"
			nine
		else
			todo

literal nat64(s str)
	when
		s empty?
			zero
		else
			higher-digits = s.rtail.literal as<nat64>
			higher-digits * ten + (char-to-nat64: s last)

literal int64(s str)
	fst = s at zero
	when
		fst == "-"
			n = as<nat64>: s.tail.literal
			n neg
		fst == "+"
			s.tail.literal.as<nat64> to-int64
		else
			s.literal.as<nat64> to-int64

region Util

pass void() noctx builtin
pass fut void() noctx builtin
drop void(t ?t) noctx
	pass

hard-assert void(condition bool) noctx unsafe
	when
		condition
			pass
		else
			"Assertion failed!" hard-fail

assert void(condition bool)
	when
		condition
			pass
		else
			"Assertion failed!" fail

hard-forbid void(condition bool) noctx unsafe
	condition.not hard-assert

forbid void(condition bool)
	condition.not assert

hard-assert-unreachable ?t() noctx unsafe
	"should be unreachable" hard-fail

assert-unreachable ?t()
	"should be unreachable" fail

some<?t> record
	value ?t
none record
opt<?t> union
	none
	some<?t>

empty? bool(a opt ?t) noctx
	match a
		none n
			true
		some s
			false

has? bool(a opt ?t) noctx
	a.empty? not

as ?t(value ?t) noctx builtin
as-non-const ?t(value ?t) noctx builtin

region fut

fut<?t> builtin sendable
resolved fut ?t(value ?t)
	todo
then fut ?out(a fut ?in, cb remote-fun1 ?out ?in)
	todo
join fut ?out(a fut ?in0, b fut ?in1, cb remote-fun2 ?out ?in0 ?in1)
	todo

region arr

| NOTE: this is not a normal record, compiler treats it specially
arr<?t> record
	size nat64
	data ptr ?t

empty-arr arr ?t() noctx trusted
	| TODO: should be able to infer type argument to null!
	new zero, null<?t>

empty? bool(a arr ?t)
	a.size == zero

slice arr ?t(a arr ?t, begin nat64, size nat64) trusted
	assert: begin + size <= a.size
	new size, a.data + begin

slice arr ?t(a arr ?t, begin nat64)
	assert: begin <= a.size
	a slice: begin, a.size - begin

first ?t(a arr ?t)
	forbid: a empty?
	a at zero

last ?t(a arr ?t)
	forbid: a empty?
	a at a.size.decr

tail arr ?t(a arr ?t)
	forbid: a empty?
	a slice one

rtail arr ?t(a arr ?t)
	forbid: a empty?
	a slice zero, a.size.decr

noctx-at ?t(a arr ?t, index nat64) trusted noctx
	hard-assert: index < a.size
	a.data + index deref

at ?t(a arr ?t, index nat64) trusted
	assert: index < a.size
	a.data + index deref

cat arr ?t(a arr ?t, b arr ?t) trusted
	m = uninitialized-mut-arr<?t>: a.size + b.size
	zero to a.size each \i
		m set-at: i, a at i
	zero to b.size each \i
		m set-at: (i + a.size), (b at i)
	m freeze

| NOTE: this is not a normal record, compiler treats it specially
mut-arr<?t> record
	frozen mut bool
	| Number of *initialized* elements.
	| But 'uninitialized-mut-arr' sets 'size' and doesn't initialize!
	size mut nat64
	capacity mut nat64
	data mut ptr ?t

uninitialized-data ptr ?t(size nat64) unsafe
	bptr = allocate-bytes: size wrapping-mul size-of<?t>
	bptr ptr-cast<?t, byte>

uninitialized-mut-arr mut-arr ?t(size nat64) unsafe
	new false, size, size, uninitialized-data<?t>: size

new-mut-arr mut-arr ?t() trusted
	new false, zero, zero, null

new-mut-arr-by-val by-val mut-arr<?t>() noctx trusted
	new false, zero, zero, null

set-at void(a mut-arr ?t, index nat64, value ?t) trusted
	assert: index < a.size
	(a.data + index) set value

| Unsafe as this does *not* freeze it!
unsafe-as-arr arr ?t(a mut-arr ?t) noctx unsafe
	new a.size, a.data

freeze arr ?t(a mut-arr ?t) noctx trusted
	a.frozen := true
	a unsafe-as-arr

at ?t(a mut-arr ?t, index nat64) trusted
	when
		index < a.size
			a.data + index deref
		else
			fail: "bad mut-arr index"

copy-data-from void(to ptr ?t, from ptr ?t, len nat64) unsafe
	when
		len == zero
			pass
		else
			to set: from deref
			| TODO: should be able to infer type arguments
			to.incr copy-data-from<?t> from.incr, len.decr

add void(a mut-arr ?t, value ?t) trusted
	when
		a.size == a.capacity
			| Allocate a bigger one
			old-data = a.data
			a.capacity := a.size == zero if: four, a.size * two
			a.data := uninitialized-data<?t>: a.capacity
			a.data copy-data-from old-data, a.size
		else
			pass
	a.size < a.capacity assert
	(a.data + a.size) set value
	a.size := a.size incr

make-arr arr ?t(size nat64, f fun1 ?t nat64)
	size make-mut-arr f freeze

make-mut-arr mut-arr ?t(size nat64, f fun1 ?t nat64) trusted
	res = uninitialized-mut-arr<?t>: size
	zero to size each \i
		res set-at: i, f call i
	res

to-mut-arr mut-arr ?t(a arr ?t)
	a.size make-mut-arr<?t> \i
		a at i

| Currently only used to implement print-sync, so don't worry about varargs
| TODO: 'summon'
printf void(format c-str, sz nat64, data ptr char) unsafe extern

print-sync void(s str) summon trusted noctx
	printf: "%.*s\n\0".data, s.size, s.data

debug-print void(s str) trusted noctx
	printf: "%.*s\n\0".data, s.size, s.data

| Used to make code run after the actor's next step. Equivalent to `sleep 0`.
delay fut void() noctx
	pass

to-str str(b bool)
	b if "true", "false"

to-str str(n nat64)
	when
		n == 0
			"0"
		n == 1
			"1"
		n == 2
			"2"
		n == 3
			"3"
		n == 4
			"4"
		n == 5
			"5"
		n == 6
			"6"
		n == 7
			"7"
		n == 8
			"8"
		n == 9
			"9"
		else
			hi = to-str: n / ten
			lo = to-str: n mod ten
			hi cat lo

to-str str(i int64)
	a = i.abs to-str
	| TODO: string interpolation
	i.negative? if ("-" cat a), a

region dict

key-value-pair<?k, ?v> record
	key ?k
	value ?v

dict<?k, ?v> record
	keys arr ?k
	values arr ?v

empty-dict dict ?k ?v()
	| TODO: should be able to infer type arguments
	new empty-arr<?k>, empty-arr<?v>

mut-dict<?k, ?v> record
	keys mut-arr ?k
	values mut-arr ?v

empty-mut-dict mut-dict ?k ?v()
	| TODO: should be able to infer type arguments -- worked when there was only one field...
	new new-mut-arr<?k>, new-mut-arr<?v>

unsafe-as-dict dict ?k ?v(m mut-dict ?k ?v) unsafe
	new m.keys.unsafe-as-arr, m.values.unsafe-as-arr

freeze dict ?k ?v(m mut-dict ?k ?v)
	new m.keys.freeze, m.values.freeze

get-recursive<?k, ?v> opt ?v(keys arr ?k, values arr ?v, idx nat64, key ?k)
	when
		idx == keys.size
			new<none>
		key ==: keys at idx
			new<some<?v>> values at idx
		else
			| TODO: should not need to provide type arguments!
			get-recursive<?k, ?v>: keys, values, idx.incr, key

get opt ?v(d dict ?k ?v, key ?k) trusted
	| TODO: should not need to provide type arguments
	get-recursive<?k, ?v>: d.keys, d.values, 0, key

get opt ?v(d mut-dict ?k ?v, key ?k) trusted
	d.unsafe-as-dict get key

at ?v(d dict ?k ?v, key ?k)
	match d get key
		none
			todo
		some s
			s.value


at ?v(d mut-dict ?k ?v, key ?k) trusted
	d.unsafe-as-dict at key

has? bool(d dict ?k ?v, key ?k)
	d get key has?

has? bool(d mut-dict ?k ?v, key ?k) trusted
	d.unsafe-as-dict has? key

add void(m mut-dict ?k ?v, key ?k, value ?v)
	forbid: m has? key
	m.keys add key
	m.values add value

map arr ?out(a arr ?in, mapper fun1 ?out ?in) trusted
	out = uninitialized-mut-arr<?out>: a.size
	zero to a.size each \i
		out set-at: i, mapper call: a at i
	out freeze

map-values dict ?k ?v-out(d dict ?k ?v-in, mapper fun1 ?v-out ?v-in)
	new-values = d.values map mapper
	new d.keys, new-values


region cell

cell<?t> record mut
	value mut ?t

get ?t(c cell ?t)
	c.value

set void(c cell ?t, v ?t)
	c.value := v

get-and-incr nat64(c cell nat64)
	res = c get
	c set: res incr
	res

region iterator

| TODO: ALIAS
iterator<?t> record mut
	get-next fun0 opt<?t>

next opt ?t(i iterator ?t)
	i.get-next call

| Iterator that can be started over from the beginning.
stream<?t> record mut
	get-iter fun0 iterator<?t>

iter iterator ?t(s stream ?t)
	s.get-iter call

iter<?t, ?e> spec
	iter iterator ?e(t ?t)

to-stream<?t, ?e> stream ?e(t ?t) iter<?t, ?e>
	new {t iter}

region range

range-nat64 record
	| lo inclusive, hi exclusive
	lo nat64
	hi nat64

iter iterator nat64(r range-nat64)
	n = new<cell<nat64>> r.lo
	new \
		when
			n.get == r.hi
				new<none>
			else
				new<some<nat64>> n get-and-incr

to range-nat64(lo nat64, hi nat64)
	lo <= hi assert
	new lo, hi

empty? bool(r range-nat64)
	r.lo == r.hi

tail range-nat64(r range-nat64)
	r.empty? forbid
	r.lo.incr to r.hi

each void(s stream ?t, f fun1 void ?t)
	s.iter each-recur f

each void(r range-nat64, f fun1 void nat64)
	r.iter each-recur f

each-recur void(i iterator ?t, f fun1 void ?t)
	match i next
		none
			pass
		some s
			f call s.value
			i each-recur f

filter stream ?t(in stream ?t, pred fun1 bool ?t)
	new \
		itr = in iter
		new {itr filter-helper pred}

filter-helper opt ?t(i iterator ?t, pred fun1 bool ?t)
	match i next
		none
			new<none>
		some s
			v = s.value
			when
				pred call v
					new<some<?t>> v
				else
					| This one didn't satisfy the predicate, but keep trying until we get one or each the end
					i filter-helper pred

sum nat64(t ?t) iter<?t, nat64>
	t.iter sum-helper

sum-helper nat64(i iterator nat64)
	match i.next
		none
			zero
		some s
			s.value + i.sum-helper


region atomic

atomic-bool record
	value mut bool

new-atomic-bool by-val atomic-bool() noctx
	new false

| TODO: works on any primitive type, not just bool
compare-exchange-strong bool(value-ptr ptr bool, expected-ptr ptr bool, desired bool) noctx builtin

try-change bool(a atomic-bool, old-value bool) noctx trusted
	a.value.ptr-to compare-exchange-strong old-value.ptr-to, old-value.not

try-set bool(a atomic-bool) noctx
	a try-change false

try-unset bool(a atomic-bool) noctx
	a try-change true

must-unset void(a atomic-bool) noctx unsafe
	did-unset = a try-unset
	did-unset hard-assert

lock record
	by-ref
	| Storing this by-val to avoid needing allocations.
	| User should prefer to store the lock by-val too, and only pass by-ref
	is-locked by-val atomic-bool

new-lock by-val lock() noctx
	new new-atomic-bool

try-acquire-lock bool(l lock) noctx trusted
	l.is-locked.ref-of-val try-set

acquire-lock void(l lock) noctx unsafe
	l acquire-lock-recur zero

acquire-lock-recur void(l lock, n-tries nat64) noctx unsafe
	when
		l.try-acquire-lock
			pass
		n-tries == thousand
			hard-fail: "Couldn't acquire lock after 1000 tries"
		else
			l acquire-lock-recur n-tries.incr

release-lock void(l lock) noctx unsafe
	l.is-locked.ref-of-val must-unset

with-lock ?t(l lock, f fun0 ?t) trusted
	l acquire-lock
	res = f call
	l release-lock
	res

condition record
	lk by-val lock
	value mut nat64

new-condition by-val condition() noctx
	new new-lock, zero

broadcast void(c condition) trusted
	c.lk.ref-of-val with-lock \
		c.value := c.value incr

get-last-checked nat64(c condition) noctx
	c.value

usleep void(micro-seconds nat64) extern

| TODO:MOVE
sleep-ms-sync void(ms nat64) noctx
	| TODO: wrapping-mul is unsafe
	ms wrapping-mul thousand usleep

wait-on void(c condition, last-checked nat64) noctx
	when
		c.value == last-checked
			pass
		else
			hundred sleep-ms-sync


| TODO: use atomic operations for this
thread-safe-counter record
	lk by-val lock
	value mut nat64

new-thread-safe-counter by-val thread-safe-counter() noctx
	new new-lock, zero

increment void(t thread-safe-counter) noctx
	t.get-and-increment drop

get-and-increment nat64(t thread-safe-counter) noctx trusted
	l = t.lk.ref-of-val
	l acquire-lock
	res = t.value
	t.value := t.value incr
	l release-lock
	res

| Returns true if the counter is now 0.
decrement bool(t thread-safe-counter) noctx
	t.get-and-decrement == zero

get-and-decrement nat64(t thread-safe-counter) noctx trusted
	l = t.lk.ref-of-val
	l acquire-lock
	res = t.value
	hard-forbid: res == zero
	t.value := t.value decr-noctx
	l release-lock
	res

region runtime

global-ctx record mut
	lk by-val lock
	| TODO: mut-arr
	vats mut arr vat
	n-live-threads mut nat64
	may-be-work-to-do by-val condition
	is-shut-down mut bool

new-global-ctx by-val global-ctx() noctx
	new new-lock, empty-arr<vat>, zero, new-condition, false

vat-id alias
	nat64
actor-id alias
	nat64


gc record mut
	lk by-val lock
	is-doing-gc mut bool
	begin ptr byte
	next ptr byte

new-gc by-val gc() noctx
	new new-lock, false, null, null

task record mut
	by-val
	fun fun0 void
	actor-id opt actor-id

linked-mut-queue-node<?t> record
	value ?t
	next opt linked-mut-queue-node<?t>

linked-mut-queue<?t> record mut
	head mut opt linked-mut-queue-node<?t>
	tail mut opt linked-mut-queue-node<?t>

new-linked-mut-queue by-val linked-mut-queue<?t>() noctx
	new new<none>, new<none>

vat record mut
	gctx global-ctx
	id vat-id
	| TODO: name this 'gc', currently that causes compilation errors
	g by-val gc

	| these variables are all protected by tasks-lock
	tasks-lock by-val lock
	tasks by-val linked-mut-queue<task>
	| TODO: mut-set
	currently-running-actors by-val mut-arr<actor-id>
	n-threads-running nat64

	| not protected by tasks-lock, thread-safe on its own
	next-actor-id by-val thread-safe-counter

new-actor actor-id(v vat) noctx trusted
	v.next-actor-id.ref-of-val get-and-increment

new-vat by-val vat(gctx global-ctx, id vat-id) noctx
	new gctx, id, new-gc, new-lock, new-linked-mut-queue, new-mut-arr-by-val, zero, new-thread-safe-counter

| This will be a large struct
ctx record mut
	vt vat
	actor-id opt actor-id
	| TODO: exception context

new-ctx by-val ctx(vat vat, actor-id opt actor-id) noctx
	new vat, actor-id
